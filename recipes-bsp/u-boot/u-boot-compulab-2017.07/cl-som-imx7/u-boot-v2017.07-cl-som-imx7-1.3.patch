 Makefile                                          |   2 +-
 arch/arm/cpu/arm926ejs/mxs/clock.c                |   5 +-
 arch/arm/cpu/armv7/mx6/clock.c                    |  18 +-
 arch/arm/cpu/armv7/mx7/Kconfig                    |  10 +
 arch/arm/cpu/armv7/mx7/Makefile                   |   2 +-
 arch/arm/cpu/armv7/mx7/clock.c                    |  10 +-
 arch/arm/cpu/armv7/mx7/ddr.c                      | 229 +++++++
 arch/arm/imx-common/spl.c                         |  23 +-
 arch/arm/include/asm/arch-mx6/clock.h             |   2 +-
 arch/arm/include/asm/arch-mx7/clock.h             |   2 +-
 arch/arm/include/asm/arch-mx7/crm_regs.h          |  51 +-
 arch/arm/include/asm/arch-mx7/imx-regs.h          |   2 +
 arch/arm/include/asm/arch-mx7/mx7-ddr.h           | 168 ++++++
 arch/arm/include/asm/arch-mx7/sys_proto.h         |   1 +
 arch/arm/include/asm/arch-mxs/clock.h             |   2 +-
 arch/arm/include/asm/imx-common/regs-bch.h        |   6 +-
 board/aries/m28evk/m28evk.c                       |   6 +-
 board/compulab/cl-som-am57x/cl-som-am57x.c        |   2 +
 board/compulab/cl-som-am57x/eth.c                 |   1 +
 board/compulab/cl-som-imx7/Kconfig                |  28 +
 board/compulab/cl-som-imx7/MAINTAINERS            |   6 +
 board/compulab/cl-som-imx7/Makefile               |  18 +
 board/compulab/cl-som-imx7/cl-som-imx7.c          | 693 ++++++++++++++++++++++
 board/compulab/cl-som-imx7/common.c               |  46 ++
 board/compulab/cl-som-imx7/common.h               |  61 ++
 board/compulab/cl-som-imx7/display.c              | 567 ++++++++++++++++++
 board/compulab/cl-som-imx7/mux.c                  | 241 ++++++++
 board/compulab/cl-som-imx7/spl.c                  | 204 +++++++
 board/compulab/cm_fx6/cm_fx6.c                    |   1 +
 board/compulab/cm_t335/cm_t335.c                  |   1 +
 board/compulab/cm_t35/cm_t35.c                    |   1 +
 board/compulab/cm_t3517/cm_t3517.c                |   1 +
 board/compulab/cm_t54/cm_t54.c                    |   1 +
 board/compulab/common/common.c                    | 204 ++++++-
 board/compulab/common/common.h                    |  32 +
 board/compulab/common/eeprom.c                    | 224 ++++---
 board/compulab/common/eeprom.h                    |   5 +
 board/corscience/tricorder/tricorder-eeprom.c     |   4 +-
 board/freescale/mpc8323erdb/mpc8323erdb.c         |   2 +-
 board/freescale/mx28evk/mx28evk.c                 |   6 +-
 board/freescale/mx6sxsabreauto/mx6sxsabreauto.c   |   2 +-
 board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c |   3 +-
 board/freescale/mx7dsabresd/mx7dsabresd.c         |   2 +-
 board/kosagi/novena/novena.c                      |   2 +-
 board/ppcag/bg0900/bg0900.c                       |   3 +-
 board/samtec/vining_2000/vining_2000.c            |   2 +-
 board/samtec/vining_fpga/socfpga.c                |   2 +-
 board/schulercontrol/sc_sps_1/sc_sps_1.c          |   6 +-
 board/technexion/pico-imx7d/pico-imx7d.c          |   2 +-
 board/toradex/colibri_imx7/colibri_imx7.c         |   2 +-
 board/xilinx/zynq/board.c                         |   2 +-
 board/xilinx/zynqmp/zynqmp.c                      |   2 +-
 cmd/eeprom.c                                      |  28 +-
 common/eeprom/eeprom_field.c                      | 116 +++-
 common/eeprom/eeprom_layout.c                     |  58 +-
 common/env_eeprom.c                               |   4 +-
 configs/cl_som_imx7_defconfig                     |  69 +++
 drivers/mtd/nand/mxs_nand.c                       | 218 +++++--
 drivers/net/fec_mxc.c                             |   7 +-
 drivers/usb/host/ehci-mx6.c                       |   9 +
 drivers/video/mxsfb.c                             |   5 +-
 include/common.h                                  |  10 +-
 include/configs/cl-som-imx7.h                     | 255 ++++++++
 include/configs/imx7_spl.h                        |  67 +++
 include/configs/tam3517-common.h                  |   2 +-
 include/eeprom_field.h                            |  45 +-
 include/eeprom_layout.h                           |   2 +
 include/netdev.h                                  |   3 +-
 tools/logos/compulab.bmp                          | Bin 31810 -> 46978 bytes
 69 files changed, 3557 insertions(+), 259 deletions(-)

diff --git a/Makefile b/Makefile
index 119ad49..89194bc 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,7 @@
 VERSION = 2017
 PATCHLEVEL = 07
 SUBLEVEL =
-EXTRAVERSION =
+EXTRAVERSION = -cl-som-imx7-1.3
 NAME =
 
 # *DOCUMENTATION*
diff --git a/arch/arm/cpu/arm926ejs/mxs/clock.c b/arch/arm/cpu/arm926ejs/mxs/clock.c
index b552e43..cb1ba00 100644
--- a/arch/arm/cpu/arm926ejs/mxs/clock.c
+++ b/arch/arm/cpu/arm926ejs/mxs/clock.c
@@ -309,7 +309,7 @@ void mxs_set_ssp_busclock(unsigned int bus, uint32_t freq)
 		bus, tgtclk, freq);
 }
 
-void mxs_set_lcdclk(uint32_t __maybe_unused lcd_base, uint32_t freq)
+int mxs_set_lcdclk(uint32_t __maybe_unused lcd_base, uint32_t freq)
 {
 	struct mxs_clkctrl_regs *clkctrl_regs =
 		(struct mxs_clkctrl_regs *)MXS_CLKCTRL_BASE;
@@ -317,7 +317,7 @@ void mxs_set_lcdclk(uint32_t __maybe_unused lcd_base, uint32_t freq)
 	int32_t k_best_l = 999, k_best_t = 0, x_best_l = 0xff, x_best_t = 0xff;
 
 	if (freq == 0)
-		return;
+		return -1;
 
 #if defined(CONFIG_MX23)
 	writel(CLKCTRL_CLKSEQ_BYPASS_PIX, &clkctrl_regs->hw_clkctrl_clkseq_clr);
@@ -400,6 +400,7 @@ void mxs_set_lcdclk(uint32_t __maybe_unused lcd_base, uint32_t freq)
 	while (readl(&clkctrl_regs->hw_clkctrl_lcdif) & CLKCTRL_DIS_LCDIF_BUSY)
 		;
 #endif
+	return 0;
 }
 
 uint32_t mxc_get_clock(enum mxc_clock clk)
diff --git a/arch/arm/cpu/armv7/mx6/clock.c b/arch/arm/cpu/armv7/mx6/clock.c
index 84bc213..e9ead5c 100644
--- a/arch/arm/cpu/armv7/mx6/clock.c
+++ b/arch/arm/cpu/armv7/mx6/clock.c
@@ -615,7 +615,7 @@ static int enable_pll_video(u32 pll_div, u32 pll_num, u32 pll_denom,
  *
  * 'freq' using KHz as unit, see driver/video/mxsfb.c.
  */
-void mxs_set_lcdclk(u32 base_addr, u32 freq)
+int mxs_set_lcdclk(u32 base_addr, u32 freq)
 {
 	u32 reg = 0;
 	u32 hck = MXC_HCLK / 1000;
@@ -631,7 +631,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 	if (!is_mx6sx() && !is_mx6ul() && !is_mx6ull() && !is_mx6sl() &&
 	    !is_mx6sll()) {
 		debug("This chip not support lcd!\n");
-		return;
+		return -1;
 	}
 
 	if (!is_mx6sl()) {
@@ -639,7 +639,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 			reg = readl(&imx_ccm->cscdr2);
 			/* Can't change clocks when clock not from pre-mux */
 			if ((reg & MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK) != 0)
-				return;
+				return -1;
 		}
 	}
 
@@ -647,7 +647,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 		reg = readl(&imx_ccm->cscdr2);
 		/* Can't change clocks when clock not from pre-mux */
 		if ((reg & MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK) != 0)
-			return;
+			return -1;
 	}
 
 	temp = freq * max_pred * max_postd;
@@ -670,7 +670,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 
 		if (post_div > 4) {
 			printf("Fail to set rate to %dkhz", freq);
-			return;
+			return -1;
 		}
 	}
 
@@ -690,7 +690,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 
 	if (best == 0) {
 		printf("Fail to set rate to %dKHz", freq);
-		return;
+		return -1;
 	}
 
 	debug("best %d, pred = %d, postd = %d\n", best, pred, postd);
@@ -709,7 +709,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 
 	if (base_addr == LCDIF1_BASE_ADDR) {
 		if (enable_pll_video(pll_div, pll_num, pll_denom, post_div))
-			return;
+			return -1;
 
 		enable_lcdif_clock(base_addr, 0);
 		if (!is_mx6sl()) {
@@ -746,7 +746,7 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 	} else if (is_mx6sx()) {
 		/* Setting LCDIF2 for i.MX6SX */
 		if (enable_pll_video(pll_div, pll_num, pll_denom, post_div))
-			return;
+			return -1;
 
 		enable_lcdif_clock(base_addr, 0);
 		/* Select pre-lcd clock to PLL5 and set pre divider */
@@ -765,6 +765,8 @@ void mxs_set_lcdclk(u32 base_addr, u32 freq)
 
 		enable_lcdif_clock(base_addr, 1);
 	}
+
+	return 0;
 }
 
 int enable_lcdif_clock(u32 base_addr, bool enable)
diff --git a/arch/arm/cpu/armv7/mx7/Kconfig b/arch/arm/cpu/armv7/mx7/Kconfig
index aea8526..19e52b0 100644
--- a/arch/arm/cpu/armv7/mx7/Kconfig
+++ b/arch/arm/cpu/armv7/mx7/Kconfig
@@ -18,6 +18,15 @@ choice
 	prompt "MX7 board select"
 	optional
 
+config TARGET_CL_SOM_IMX7
+	bool "CL-SOM-iMX7"
+	select MX7D
+	select DM
+	select DM_THERMAL
+	select SUPPORT_SPL
+	select COMPULAB_COMMON
+	select SYS_I2C_EEPROM_BASE
+
 config TARGET_MX7DSABRESD
 	bool "mx7dsabresd"
 	select BOARD_LATE_INIT
@@ -51,6 +60,7 @@ endchoice
 config SYS_SOC
 	default "mx7"
 
+source "board/compulab/cl-som-imx7/Kconfig"
 source "board/freescale/mx7dsabresd/Kconfig"
 source "board/technexion/pico-imx7d/Kconfig"
 source "board/toradex/colibri_imx7/Kconfig"
diff --git a/arch/arm/cpu/armv7/mx7/Makefile b/arch/arm/cpu/armv7/mx7/Makefile
index d21f87f..ce289c1 100644
--- a/arch/arm/cpu/armv7/mx7/Makefile
+++ b/arch/arm/cpu/armv7/mx7/Makefile
@@ -5,7 +5,7 @@
 #
 #
 
-obj-y	:= soc.o clock.o clock_slice.o
+obj-y	:= soc.o clock.o clock_slice.o ddr.o
 
 ifdef CONFIG_ARMV7_PSCI
 obj-y  += psci-mx7.o psci.o
diff --git a/arch/arm/cpu/armv7/mx7/clock.c b/arch/arm/cpu/armv7/mx7/clock.c
index 2cfde46..0bef0ae 100644
--- a/arch/arm/cpu/armv7/mx7/clock.c
+++ b/arch/arm/cpu/armv7/mx7/clock.c
@@ -889,7 +889,7 @@ int set_clk_nand(void)
 	return 0;
 }
 
-void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
+int mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
 {
 	u32 hck = MXC_HCLK/1000;
 	u32 min = hck * 27;
@@ -915,7 +915,7 @@ void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
 
 		if (5 == i) {
 			printf("Fail to set rate to %dkhz", freq);
-			return;
+			return -1;
 		}
 	}
 
@@ -935,7 +935,7 @@ void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
 
 	if (best == 0) {
 		printf("Fail to set rate to %dkhz", freq);
-		return;
+		return -1;
 	}
 
 	debug("best %d, pred = %d, postd = %d\n", best, pred, postd);
@@ -945,13 +945,15 @@ void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
 	pll_num = (best - hck * pll_div) * pll_denom / hck;
 
 	if (enable_pll_video(pll_div, pll_num, pll_denom, post_div))
-		return;
+		return -1;
 
 	target = CLK_ROOT_ON | LCDIF_PIXEL_CLK_ROOT_FROM_PLL_VIDEO_MAIN_CLK |
 		 CLK_ROOT_PRE_DIV((pred - 1)) | CLK_ROOT_POST_DIV((postd - 1));
 	clock_set_target_val(LCDIF_PIXEL_CLK_ROOT, target);
 
 	clock_enable(CCGR_LCDIF, 1);
+
+	return 0;
 }
 
 #ifdef CONFIG_FEC_MXC
diff --git a/arch/arm/cpu/armv7/mx7/ddr.c b/arch/arm/cpu/armv7/mx7/ddr.c
new file mode 100644
index 0000000..b3702b3
--- /dev/null
+++ b/arch/arm/cpu/armv7/mx7/ddr.c
@@ -0,0 +1,229 @@
+/*
+ * DDR controller configuration for the i.MX7 architecture
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <linux/types.h>
+#include <asm/io.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx7-ddr.h>
+#include <common.h>
+
+#define POLLING_COUNT_MAX 1000
+/* Recommended DDR PHY calibration value */
+#define CTRL_ZQ_CLK_DIV_VAL (0x7 & ZQ_CON2_CTRL_ZQ_CLK_DIV_MASK)
+#define DDR_PHY_CTRL_WAKE_UP_VAL 0xf
+
+/*
+ * Routine: mx7_dram_cfg
+ * Description: DDR controller configuration
+ *
+ * @ddrc_regs_val: DDRC registers value
+ * @ddrc_mp_val: DDRC_MP registers value
+ * @ddr_phy_regs_val: DDR_PHY registers value
+ * @return: 0 on success, 1 otherwise
+ */
+int mx7_dram_cfg(struct ddrc *ddrc_regs_val, struct ddrc_mp *ddrc_mp_val,
+		 struct ddr_phy *ddr_phy_regs_val)
+{
+	struct src *const src_regs = (struct src *)SRC_BASE_ADDR;
+	struct ddrc *const ddrc_regs = (struct ddrc *)DDRC_IPS_BASE_ADDR;
+	struct ddrc_mp *const ddrc_mp_reg = (struct ddrc_mp *)DDRC_MP_BASE_ADDR;
+	struct ddr_phy *const ddr_phy_regs =
+		(struct ddr_phy *)DDRPHY_IPS_BASE_ADDR;
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs =
+		(struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+	u32 reg_val;
+	int polling_count = 0;
+
+	/* Assert DDR Controller preset and DDR PHY reset */
+	writel(SRC_DDRC_RCR_DDRC_CORE_RST_MASK, &src_regs->ddrc_rcr);
+
+	/* DDR controller configuration */
+	writel(ddrc_regs_val->mstr, &ddrc_regs->mstr);
+	writel(ddrc_regs_val->rfshtmg, &ddrc_regs->rfshtmg);
+	writel(ddrc_mp_val->pctrl_0, &ddrc_mp_reg->pctrl_0);
+	writel(ddrc_regs_val->init1, &ddrc_regs->init1);
+	writel(ddrc_regs_val->init0, &ddrc_regs->init0);
+	writel(ddrc_regs_val->init3, &ddrc_regs->init3);
+	writel(ddrc_regs_val->init4, &ddrc_regs->init4);
+	writel(ddrc_regs_val->init5, &ddrc_regs->init5);
+	writel(ddrc_regs_val->rankctl, &ddrc_regs->rankctl);
+	writel(ddrc_regs_val->dramtmg0, &ddrc_regs->dramtmg0);
+	writel(ddrc_regs_val->dramtmg1, &ddrc_regs->dramtmg1);
+	writel(ddrc_regs_val->dramtmg2, &ddrc_regs->dramtmg2);
+	writel(ddrc_regs_val->dramtmg3, &ddrc_regs->dramtmg3);
+	writel(ddrc_regs_val->dramtmg4, &ddrc_regs->dramtmg4);
+	writel(ddrc_regs_val->dramtmg5, &ddrc_regs->dramtmg5);
+	writel(ddrc_regs_val->dramtmg8, &ddrc_regs->dramtmg8);
+	writel(ddrc_regs_val->zqctl0, &ddrc_regs->zqctl0);
+	writel(ddrc_regs_val->dfitmg0, &ddrc_regs->dfitmg0);
+	writel(ddrc_regs_val->dfitmg1, &ddrc_regs->dfitmg1);
+	writel(ddrc_regs_val->dfiupd0, &ddrc_regs->dfiupd0);
+	writel(ddrc_regs_val->dfiupd1, &ddrc_regs->dfiupd1);
+	writel(ddrc_regs_val->dfiupd2, &ddrc_regs->dfiupd2);
+	writel(ddrc_regs_val->addrmap0, &ddrc_regs->addrmap0);
+	writel(ddrc_regs_val->addrmap1, &ddrc_regs->addrmap1);
+	writel(ddrc_regs_val->addrmap4, &ddrc_regs->addrmap4);
+	writel(ddrc_regs_val->addrmap5, &ddrc_regs->addrmap5);
+	writel(ddrc_regs_val->addrmap6, &ddrc_regs->addrmap6);
+	writel(ddrc_regs_val->odtcfg, &ddrc_regs->odtcfg);
+	writel(ddrc_regs_val->odtmap, &ddrc_regs->odtmap);
+
+	/* De-assert DDR Controller preset and DDR PHY reset */
+	clrbits_le32(&src_regs->ddrc_rcr, SRC_DDRC_RCR_DDRC_CORE_RST_MASK);
+
+	/* PHY configuration */
+	writel(ddr_phy_regs_val->phy_con0, &ddr_phy_regs->phy_con0);
+	writel(ddr_phy_regs_val->phy_con1, &ddr_phy_regs->phy_con1);
+	writel(ddr_phy_regs_val->phy_con4, &ddr_phy_regs->phy_con4);
+	writel(ddr_phy_regs_val->mdll_con0, &ddr_phy_regs->mdll_con0);
+	writel(ddr_phy_regs_val->drvds_con0, &ddr_phy_regs->drvds_con0);
+	writel(ddr_phy_regs_val->offset_wr_con0, &ddr_phy_regs->offset_wr_con0);
+	writel(ddr_phy_regs_val->offset_rd_con0, &ddr_phy_regs->offset_rd_con0);
+	writel(ddr_phy_regs_val->cmd_sdll_con0 |
+	       DDR_PHY_CMD_SDLL_CON0_CTRL_RESYNC_MASK,
+	       &ddr_phy_regs->cmd_sdll_con0);
+	writel(ddr_phy_regs_val->cmd_sdll_con0 &
+	       ~DDR_PHY_CMD_SDLL_CON0_CTRL_RESYNC_MASK,
+	       &ddr_phy_regs->cmd_sdll_con0);
+	writel(ddr_phy_regs_val->offset_lp_con0, &ddr_phy_regs->offset_lp_con0);
+
+	/* calibration */
+	clrbits_le32(&ddr_phy_regs->zq_con0, ZQ_CON0_ZQ_MANUAL_STR_MASK);
+	clrbits_le32(&ddr_phy_regs->zq_con0, ZQ_CON0_ZQ_CLK_DIV_EN_MASK);
+	writel(CTRL_ZQ_CLK_DIV_VAL, &ddr_phy_regs->zq_con2);
+	setbits_le32(&ddr_phy_regs->zq_con0, ZQ_CON0_ZQ_CLK_DIV_EN_MASK);
+	reg_val = readl(&ddr_phy_regs->zq_con0);
+	reg_val &= ~ZQ_CON0_ZQ_MANUAL_MODE_MASK;
+	reg_val |= ZQ_CON0_ZQ_MANUAL_MODE_LONG_CALIB;
+	writel(reg_val, &ddr_phy_regs->zq_con0);
+	setbits_le32(&ddr_phy_regs->zq_con0, ZQ_CON0_ZQ_MANUAL_STR_MASK);
+	while (!(readl(&ddr_phy_regs->zq_con1) & ZQ_CON1_ZQ_DONE_MASK)) {
+		udelay(1);
+		if (++polling_count > POLLING_COUNT_MAX)
+			return 1;
+	}
+	clrbits_le32(&ddr_phy_regs->zq_con0, ZQ_CON0_ZQ_MANUAL_STR_MASK);
+	clrbits_le32(&ddr_phy_regs->zq_con0, ZQ_CON0_ZQ_CLK_DIV_EN_MASK);
+
+	/* Wake_up DDR PHY */
+	HW_CCM_CCGR_WR(CCGR_IDX_DDR, CCM_CLK_ON_N_N);
+	writel(IOMUXC_GPR_GPR8_ddr_phy_ctrl_wake_up(DDR_PHY_CTRL_WAKE_UP_VAL) |
+	       IOMUXC_GPR_GPR8_ddr_phy_dfi_init_start_MASK,
+	       &iomuxc_gpr_regs->gpr[8]);
+	HW_CCM_CCGR_WR(CCGR_IDX_DDR, CCM_CLK_ON_R_W);
+
+	/* Validation of DDRC normal operation mode */
+	polling_count = 0;
+	while ((readl(&ddrc_regs->stat) & STAT_OPERATING_MODE_MASK) !=
+	       STAT_OPERATING_MODE_NORMAL) {
+		udelay(1);
+		if (++polling_count > POLLING_COUNT_MAX)
+			return 1;
+	}
+	return 0;
+}
+
+/*
+ * Routine: imx_ddr_size
+ * Description: extract the current DRAM size from the DDRC registers
+ *
+ * @return: DRAM size
+ */
+unsigned imx_ddr_size(void)
+{
+	struct ddrc *const ddrc_regs = (struct ddrc *)DDRC_IPS_BASE_ADDR;
+	u32 reg_val, field_val;
+	int bits = 0;/* Number of address bits */
+
+	/* Count data bus width bits */
+	reg_val = readl(&ddrc_regs->mstr);
+	field_val = (reg_val & MSTR_DATA_BUS_WIDTH_MASK) >> MSTR_DATA_BUS_WIDTH_SHIFT;
+	bits += 2 - field_val;
+	/* Count rank address bits */
+	field_val = (reg_val & MSTR_DATA_ACTIVE_RANKS_MASK) >> MSTR_DATA_ACTIVE_RANKS_SHIFT;
+	if (field_val > 1)
+		bits += field_val - 1;
+	/* Count column address bits */
+	bits += 2;/* Column address 0 and 1 are fixed mapped */
+	reg_val = readl(&ddrc_regs->addrmap2);
+	field_val = (reg_val & ADDRMAP2_COL_B2_MASK) >> ADDRMAP2_COL_B2_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP2_COL_B3_MASK) >> ADDRMAP2_COL_B3_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP2_COL_B4_MASK) >> ADDRMAP2_COL_B4_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP2_COL_B5_MASK) >> ADDRMAP2_COL_B5_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	reg_val = readl(&ddrc_regs->addrmap3);
+	field_val = (reg_val & ADDRMAP3_COL_B6_MASK) >> ADDRMAP3_COL_B6_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP3_COL_B7_MASK) >> ADDRMAP3_COL_B7_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP3_COL_B8_MASK) >> ADDRMAP3_COL_B8_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP3_COL_B9_MASK) >> ADDRMAP3_COL_B9_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	reg_val = readl(&ddrc_regs->addrmap4);
+	field_val = (reg_val & ADDRMAP4_COL_B10_MASK) >> ADDRMAP4_COL_B10_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	field_val = (reg_val & ADDRMAP4_COL_B11_MASK) >> ADDRMAP4_COL_B11_SHIFT;
+	if (field_val <= 7)
+		bits++;
+	/* Count row address bits */
+	reg_val = readl(&ddrc_regs->addrmap5);
+	field_val = (reg_val & ADDRMAP5_ROW_B0_MASK) >> ADDRMAP5_ROW_B0_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	field_val = (reg_val & ADDRMAP5_ROW_B1_MASK) >> ADDRMAP5_ROW_B1_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	field_val = (reg_val & ADDRMAP5_ROW_B2_10_MASK) >> ADDRMAP5_ROW_B2_10_SHIFT;
+	if (field_val <= 11)
+		bits += 9;
+	field_val = (reg_val & ADDRMAP5_ROW_B11_MASK) >> ADDRMAP5_ROW_B11_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	reg_val = readl(&ddrc_regs->addrmap6);
+	field_val = (reg_val & ADDRMAP6_ROW_B12_MASK) >> ADDRMAP6_ROW_B12_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	field_val = (reg_val & ADDRMAP6_ROW_B13_MASK) >> ADDRMAP6_ROW_B13_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	field_val = (reg_val & ADDRMAP6_ROW_B14_MASK) >> ADDRMAP6_ROW_B14_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	field_val = (reg_val & ADDRMAP6_ROW_B15_MASK) >> ADDRMAP6_ROW_B15_SHIFT;
+	if (field_val <= 11)
+		bits++;
+	/* Count bank bits */
+	reg_val = readl(&ddrc_regs->addrmap1);
+	field_val = (reg_val & ADDRMAP1_BANK_B0_MASK) >> ADDRMAP1_BANK_B0_SHIFT;
+	if (field_val <= 30)
+		bits++;
+	field_val = (reg_val & ADDRMAP1_BANK_B1_MASK) >> ADDRMAP1_BANK_B1_SHIFT;
+	if (field_val <= 30)
+		bits++;
+	field_val = (reg_val & ADDRMAP1_BANK_B2_MASK) >> ADDRMAP1_BANK_B2_SHIFT;
+	if (field_val <= 29)
+		bits++;
+
+	return 1 << bits;
+}
diff --git a/arch/arm/imx-common/spl.c b/arch/arm/imx-common/spl.c
index f392941..e470868 100644
--- a/arch/arm/imx-common/spl.c
+++ b/arch/arm/imx-common/spl.c
@@ -14,6 +14,7 @@
 #include <asm/spl.h>
 #include <spl.h>
 #include <asm/imx-common/hab.h>
+#include <asm/imx-common/boot_mode.h>
 
 #if defined(CONFIG_MX6)
 /* determine boot device from SRC_SBMR1 (BOOT_CFG[4:1]) or SRC_GPR9 register */
@@ -78,7 +79,27 @@ u32 spl_boot_device(void)
 	}
 	return BOOT_DEVICE_NONE;
 }
-#endif
+
+#elif defined(CONFIG_MX7)
+/* Translate iMX7 boot device to the SPL boot device enumeration */
+u32 spl_boot_device(void)
+{
+	enum boot_device boot_device_spl = get_boot_device();
+
+	switch (boot_device_spl) {
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		return BOOT_DEVICE_MMC1;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		return BOOT_DEVICE_MMC2;
+	case SPI_NOR_BOOT:
+		return BOOT_DEVICE_SPI;
+	default:
+		return BOOT_DEVICE_NONE;
+	}
+}
+#endif /* CONFIG_MX6 || CONFIG_MX7 */
 
 #if defined(CONFIG_SPL_MMC_SUPPORT)
 /* called from spl_mmc to see type of boot mode for storage (RAW or FAT) */
diff --git a/arch/arm/include/asm/arch-mx6/clock.h b/arch/arm/include/asm/arch-mx6/clock.h
index 2d9c45e..c334564 100644
--- a/arch/arm/include/asm/arch-mx6/clock.h
+++ b/arch/arm/include/asm/arch-mx6/clock.h
@@ -77,7 +77,7 @@ void enable_enet_clk(unsigned char enable);
 int enable_lcdif_clock(u32 base_addr, bool enable);
 void enable_qspi_clk(int qspi_num);
 void enable_thermal_clk(void);
-void mxs_set_lcdclk(u32 base_addr, u32 freq);
+int mxs_set_lcdclk(u32 base_addr, u32 freq);
 void select_ldb_di_clock_source(enum ldb_di_clock clk);
 void enable_eim_clk(unsigned char enable);
 #endif /* __ASM_ARCH_CLOCK_H */
diff --git a/arch/arm/include/asm/arch-mx7/clock.h b/arch/arm/include/asm/arch-mx7/clock.h
index 688d236..6835cd8 100644
--- a/arch/arm/include/asm/arch-mx7/clock.h
+++ b/arch/arm/include/asm/arch-mx7/clock.h
@@ -343,6 +343,6 @@ void enable_usboh3_clk(unsigned char enable);
 #ifdef CONFIG_SECURE_BOOT
 void hab_caam_clock_enable(unsigned char enable);
 #endif
-void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq);
+int mxs_set_lcdclk(uint32_t base_addr, uint32_t freq);
 void enable_thermal_clk(void);
 #endif
diff --git a/arch/arm/include/asm/arch-mx7/crm_regs.h b/arch/arm/include/asm/arch-mx7/crm_regs.h
index d65d4d9..611190e 100644
--- a/arch/arm/include/asm/arch-mx7/crm_regs.h
+++ b/arch/arm/include/asm/arch-mx7/crm_regs.h
@@ -2000,29 +2000,29 @@ struct mxc_ccm_anatop_reg {
 #define TEMPMON_HW_ANADIG_TEMPSENSE_TRIM_TOG_T_MUX_ADDR(x) (((uint32_t)(((uint32_t)(x))<<TEMPMON_HW_ANADIG_TEMPSENSE_TRIM_TOG_T_MUX_ADDR_SHIFT))&TEMPMON_HW_ANADIG_TEMPSENSE_TRIM_TOG_T_MUX_ADDR_MASK)
 
 
-#define CCM_GPR(i)		(CCM_BASE_ADDRESS + CCM_GPR0_OFFSET + 0x10 * (i))
-#define CCM_OBSERVE(i)		(CCM_BASE_ADDRESS + CCM_OBSERVE0_OFFSET + 0x10 * (i))
-#define CCM_SCTRL(i)		(CCM_BASE_ADDRESS + CCM_SCTRL0_OFFSET + 0x10 * (i))
-#define CCM_CCGR(i)		(CCM_BASE_ADDRESS + CCM_CCGR0_OFFSET + 0x10 * (i))
-#define CCM_ROOT_TARGET(i)	(CCM_BASE_ADDRESS + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i))
-
-#define CCM_GPR_SET(i)		(CCM_BASE_ADDRESS + CCM_GPR0_OFFSET + 0x10 * (i) + 4)
-#define CCM_OBSERVE_SET(i)	(CCM_BASE_ADDRESS + CCM_OBSERVE0_OFFSET + 0x10 * (i) + 4)
-#define CCM_SCTRL_SET(i)	(CCM_BASE_ADDRESS + CCM_SCTRL0_OFFSET + 0x10 * (i) + 4)
-#define CCM_CCGR_SET(i)		(CCM_BASE_ADDRESS + CCM_CCGR0_OFFSET + 0x10 * (i) + 4)
-#define CCM_ROOT_TARGET_SET(i)	(CCM_BASE_ADDRESS + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i) + 4)
-
-#define CCM_GPR_CLR(i)		(CCM_BASE_ADDRESS + CCM_GPR0_OFFSET + 0x10 * (i) + 8)
-#define CCM_OBSERVE_CLR(i)	(CCM_BASE_ADDRESS + CCM_OBSERVE0_OFFSET + 0x10 * (i) + 8)
-#define CCM_SCTRL_CLR(i)	(CCM_BASE_ADDRESS + CCM_SCTRL0_OFFSET + 0x10 * (i) + 8)
-#define CCM_CCGR_CLR(i)		(CCM_BASE_ADDRESS + CCM_CCGR0_OFFSET + 0x10 * (i) + 8)
-#define CCM_ROOT_TARGET_CLR(i)	(CCM_BASE_ADDRESS + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i) + 8)
-
-#define CCM_GPR_TOGGLE(i)	(CCM_BASE_ADDRESS + CCM_GPR0_OFFSET + 0x10 * (i) + 12)
-#define CCM_OBSERVE_TOGGLE(i)	(CCM_BASE_ADDRESS + CCM_OBSERVE0_OFFSET + 0x10 * (i) + 12)
-#define CCM_SCTRL_TOGGLE(i)	(CCM_BASE_ADDRESS + CCM_SCTRL0_OFFSET + 0x10 * (i) + 12)
-#define CCM_CCGR_TOGGLE(i)	(CCM_BASE_ADDRESS + CCM_CCGR0_OFFSET + 0x10 * (i) + 12)
-#define CCM_ROOT_TARGET_TOGGLE(i)	(CCM_BASE_ADDRESS + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i) + 12)
+#define CCM_GPR(i)		(CCM_BASE_ADDR + CCM_GPR0_OFFSET + 0x10 * (i))
+#define CCM_OBSERVE(i)		(CCM_BASE_ADDR + CCM_OBSERVE0_OFFSET + 0x10 * (i))
+#define CCM_SCTRL(i)		(CCM_BASE_ADDR + CCM_SCTRL0_OFFSET + 0x10 * (i))
+#define CCM_CCGR(i)		(CCM_BASE_ADDR + CCM_CCGR0_OFFSET + 0x10 * (i))
+#define CCM_ROOT_TARGET(i)	(CCM_BASE_ADDR + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i))
+
+#define CCM_GPR_SET(i)		(CCM_BASE_ADDR + CCM_GPR0_OFFSET + 0x10 * (i) + 4)
+#define CCM_OBSERVE_SET(i)	(CCM_BASE_ADDR + CCM_OBSERVE0_OFFSET + 0x10 * (i) + 4)
+#define CCM_SCTRL_SET(i)	(CCM_BASE_ADDR + CCM_SCTRL0_OFFSET + 0x10 * (i) + 4)
+#define CCM_CCGR_SET(i)		(CCM_BASE_ADDR + CCM_CCGR0_OFFSET + 0x10 * (i) + 4)
+#define CCM_ROOT_TARGET_SET(i)	(CCM_BASE_ADDR + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i) + 4)
+
+#define CCM_GPR_CLR(i)		(CCM_BASE_ADDR + CCM_GPR0_OFFSET + 0x10 * (i) + 8)
+#define CCM_OBSERVE_CLR(i)	(CCM_BASE_ADDR + CCM_OBSERVE0_OFFSET + 0x10 * (i) + 8)
+#define CCM_SCTRL_CLR(i)	(CCM_BASE_ADDR + CCM_SCTRL0_OFFSET + 0x10 * (i) + 8)
+#define CCM_CCGR_CLR(i)		(CCM_BASE_ADDR + CCM_CCGR0_OFFSET + 0x10 * (i) + 8)
+#define CCM_ROOT_TARGET_CLR(i)	(CCM_BASE_ADDR + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i) + 8)
+
+#define CCM_GPR_TOGGLE(i)	(CCM_BASE_ADDR + CCM_GPR0_OFFSET + 0x10 * (i) + 12)
+#define CCM_OBSERVE_TOGGLE(i)	(CCM_BASE_ADDR + CCM_OBSERVE0_OFFSET + 0x10 * (i) + 12)
+#define CCM_SCTRL_TOGGLE(i)	(CCM_BASE_ADDR + CCM_SCTRL0_OFFSET + 0x10 * (i) + 12)
+#define CCM_CCGR_TOGGLE(i)	(CCM_BASE_ADDR + CCM_CCGR0_OFFSET + 0x10 * (i) + 12)
+#define CCM_ROOT_TARGET_TOGGLE(i)	(CCM_BASE_ADDR + CCM_ROOT0_TARGET_OFFSET + 0x80 * (i) + 12)
 
 #define HW_CCM_GPR_WR(i, v)		writel((v), CCM_GPR(i))
 #define HW_CCM_CCM_OBSERVE_WR(i, v)	writel((v), CCM_OBSERVE(i))
@@ -2055,6 +2055,11 @@ struct mxc_ccm_anatop_reg {
 #define HW_CCM_ROOT_TARGET_TOGGLE(i, v)	writel((v), CCM_ROOT_TARGET_TOGGLE(i))
 
 #define CCM_CLK_ON_MSK	0x03
+#define CCM_CLK_ON_N_N	0x00 /* Domain clocks not needed */
+#define CCM_CLK_ON_R_W	0x02 /* Domain clocks needed when in RUN and WAIT */
+
+/* CCGR Mapping */
+#define CCGR_IDX_DDR 19 /* CCM_CCGR19 */
 
 #define CCM_ROOT_TGT_POST_DIV_SHIFT	0
 #define CCM_ROOT_TGT_PRE_DIV_SHIFT	15
diff --git a/arch/arm/include/asm/arch-mx7/imx-regs.h b/arch/arm/include/asm/arch-mx7/imx-regs.h
index d33be31..1443dd2 100644
--- a/arch/arm/include/asm/arch-mx7/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx7/imx-regs.h
@@ -268,6 +268,8 @@ struct src {
 #define SRC_M4RCR_M4C_NON_SCLR_RST_MASK		(1 << 0)
 #define SRC_M4RCR_ENABLE_M4_OFFSET		3
 #define SRC_M4RCR_ENABLE_M4_MASK		(1 << 3)
+#define SRC_DDRC_RCR_DDRC_CORE_RST_OFFSET	1
+#define SRC_DDRC_RCR_DDRC_CORE_RST_MASK		(1 << 1)
 
 /* GPR0 Bit Fields */
 #define IOMUXC_GPR_GPR0_DMAREQ_MUX_SEL0_MASK     0x1u
diff --git a/arch/arm/include/asm/arch-mx7/mx7-ddr.h b/arch/arm/include/asm/arch-mx7/mx7-ddr.h
new file mode 100644
index 0000000..f6588b9
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx7/mx7-ddr.h
@@ -0,0 +1,168 @@
+/*
+ * DDR controller registers of the i.MX7 architecture
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX7_DDR_H__
+#define __ASM_ARCH_MX7_DDR_H__
+
+/* DDRC Registers (DDRC_IPS_BASE_ADDR) */
+struct ddrc {
+	u32 mstr;		/* 0x0000 */
+	u32 stat;		/* 0x0004 */
+	u32 reserved1[0x17];
+	u32 rfshtmg;		/* 0x0064 */
+	u32 reserved2[0x1a];
+	u32 init0;		/* 0x00d0 */
+	u32 init1;		/* 0x00d4 */
+	u32 reserved3;
+	u32 init3;		/* 0x00dc */
+	u32 init4;		/* 0x00e0 */
+	u32 init5;		/* 0x00e4 */
+	u32 reserved4[0x03];
+	u32 rankctl;		/* 0x00f4 */
+	u32 reserved5[0x02];
+	u32 dramtmg0;		/* 0x0100 */
+	u32 dramtmg1;		/* 0x0104 */
+	u32 dramtmg2;		/* 0x0108 */
+	u32 dramtmg3;		/* 0x010c */
+	u32 dramtmg4;		/* 0x0110 */
+	u32 dramtmg5;		/* 0x0114 */
+	u32 reserved6[0x02];
+	u32 dramtmg8;		/* 0x0120 */
+	u32 reserved7[0x17];
+	u32 zqctl0;		/* 0x0180 */
+	u32 reserved8[0x03];
+	u32 dfitmg0;		/* 0x0190 */
+	u32 dfitmg1;		/* 0x0194 */
+	u32 reserved9[0x02];
+	u32 dfiupd0;		/* 0x01a0 */
+	u32 dfiupd1;		/* 0x01a4 */
+	u32 dfiupd2;		/* 0x01a8 */
+	u32 reserved10[0x15];
+	u32 addrmap0;		/* 0x0200 */
+	u32 addrmap1;		/* 0x0204 */
+	u32 addrmap2;		/* 0x0208 */
+	u32 addrmap3;		/* 0x020c */
+	u32 addrmap4;		/* 0x0210 */
+	u32 addrmap5;		/* 0x0214 */
+	u32 addrmap6;		/* 0x0218 */
+	u32 reserved12[0x09];
+	u32 odtcfg;		/* 0x0240 */
+	u32 odtmap;		/* 0x0244 */
+};
+
+/* DDRC_MSTR fields */
+#define MSTR_DATA_BUS_WIDTH_MASK	0x3 << 12
+#define MSTR_DATA_BUS_WIDTH_SHIFT	12
+#define MSTR_DATA_ACTIVE_RANKS_MASK	0xf << 24
+#define MSTR_DATA_ACTIVE_RANKS_SHIFT	24
+/* DDRC_STAT fields */
+#define STAT_OPERATING_MODE_MASK	0x3 << 0
+#define STAT_OPERATING_MODE_SHIFT	0
+#define STAT_OPERATING_MODE_NORMAL	0x1 << 0
+/* DDRC_ADDRMAP1 fields */
+#define ADDRMAP1_BANK_B0_MASK		0x1f << 0
+#define ADDRMAP1_BANK_B0_SHIFT		0
+#define ADDRMAP1_BANK_B1_MASK		0x1f << 8
+#define ADDRMAP1_BANK_B1_SHIFT		8
+#define ADDRMAP1_BANK_B2_MASK		0x1f << 16
+#define ADDRMAP1_BANK_B2_SHIFT		16
+/* DDRC_ADDRMAP2 fields */
+#define ADDRMAP2_COL_B2_MASK		0xF << 0
+#define ADDRMAP2_COL_B2_SHIFT		0
+#define ADDRMAP2_COL_B3_MASK		0xF << 8
+#define ADDRMAP2_COL_B3_SHIFT		8
+#define ADDRMAP2_COL_B4_MASK		0xF << 16
+#define ADDRMAP2_COL_B4_SHIFT		16
+#define ADDRMAP2_COL_B5_MASK		0xF << 24
+#define ADDRMAP2_COL_B5_SHIFT		24
+/* DDRC_ADDRMAP3 fields */
+#define ADDRMAP3_COL_B6_MASK		0xF << 0
+#define ADDRMAP3_COL_B6_SHIFT		0
+#define ADDRMAP3_COL_B7_MASK		0xF << 8
+#define ADDRMAP3_COL_B7_SHIFT		8
+#define ADDRMAP3_COL_B8_MASK		0xF << 16
+#define ADDRMAP3_COL_B8_SHIFT		16
+#define ADDRMAP3_COL_B9_MASK		0xF << 24
+#define ADDRMAP3_COL_B9_SHIFT		24
+/* DDRC_ADDRMAP4 fields */
+#define ADDRMAP4_COL_B10_MASK		0xF << 0
+#define ADDRMAP4_COL_B10_SHIFT		0
+#define ADDRMAP4_COL_B11_MASK		0xF << 8
+#define ADDRMAP4_COL_B11_SHIFT		8
+/* DDRC_ADDRMAP5 fields */
+#define ADDRMAP5_ROW_B0_MASK		0xF << 0
+#define ADDRMAP5_ROW_B0_SHIFT		0
+#define ADDRMAP5_ROW_B1_MASK		0xF << 8
+#define ADDRMAP5_ROW_B1_SHIFT		8
+#define ADDRMAP5_ROW_B2_10_MASK		0xF << 16
+#define ADDRMAP5_ROW_B2_10_SHIFT	16
+#define ADDRMAP5_ROW_B11_MASK		0xF << 24
+#define ADDRMAP5_ROW_B11_SHIFT		24
+/* DDRC_ADDRMAP6 fields */
+#define ADDRMAP6_ROW_B12_MASK		0xF << 0
+#define ADDRMAP6_ROW_B12_SHIFT		0
+#define ADDRMAP6_ROW_B13_MASK		0xF << 8
+#define ADDRMAP6_ROW_B13_SHIFT		8
+#define ADDRMAP6_ROW_B14_MASK		0xF << 16
+#define ADDRMAP6_ROW_B14_SHIFT		16
+#define ADDRMAP6_ROW_B15_MASK		0xF << 24
+#define ADDRMAP6_ROW_B15_SHIFT		24
+
+/* DDRC_MP Registers */
+#define DDRC_MP_BASE_ADDR (DDRC_IPS_BASE_ADDR + 0x03fc)
+struct ddrc_mp {
+	u32 reserved1[0x25];
+	u32 pctrl_0;		/* 0x0094 */
+};
+
+/* DDR_PHY registers */
+struct ddr_phy {
+	u32 phy_con0;		/* 0x0000 */
+	u32 phy_con1;		/* 0x0004 */
+	u32 reserved1[0x02];
+	u32 phy_con4;		/* 0x0010 */
+	u32 reserved2;
+	u32 offset_lp_con0;	/* 0x0018 */
+	u32 reserved3;
+	u32 offset_rd_con0;	/* 0x0020 */
+	u32 reserved4[0x03];
+	u32 offset_wr_con0;	/* 0x0030 */
+	u32 reserved5[0x07];
+	u32 cmd_sdll_con0;	/* 0x0050 */
+	u32 reserved6[0x12];
+	u32 drvds_con0;		/* 0x009c */
+	u32 reserved7[0x04];
+	u32 mdll_con0;		/* 0x00b0 */
+	u32 reserved8[0x03];
+	u32 zq_con0;		/* 0x00c0 */
+	u32 zq_con1;            /* 0x00c4 */
+	u32 zq_con2;            /* 0x00c8 */
+};
+
+#define DDR_PHY_CMD_SDLL_CON0_CTRL_RESYNC_MASK (1 << 24)
+/* DDR_PHY_ZQ_CON0 */
+#define ZQ_CON0_ZQ_MANUAL_STR_MASK 0x1 << 1
+#define ZQ_CON0_ZQ_MANUAL_STR_SHIFT 1
+#define ZQ_CON0_ZQ_MANUAL_MODE_MASK 0x3 << 2
+#define ZQ_CON0_ZQ_MANUAL_MODE_SHIFT 2
+#define ZQ_CON0_ZQ_MANUAL_MODE_LONG_CALIB 0x1 << 2
+#define ZQ_CON0_ZQ_CLK_DIV_EN_MASK 1 << 18
+#define ZQ_CON0_ZQ_CLK_DIV_EN_SHIFT 18
+/* DDR_PHY_ZQ_CON1 */
+#define ZQ_CON1_ZQ_DONE_MASK 0x1 << 0
+#define ZQ_CON1_ZQ_DONE_SHIFT 0
+/* DDR_PHY_ZQ_CON2 */
+#define ZQ_CON2_CTRL_ZQ_CLK_DIV_MASK 0xffff << 0
+#define ZQ_CON2_CTRL_ZQ_CLK_DIV_SHIFT 0
+
+int mx7_dram_cfg(struct ddrc *ddrc_regs_val, struct ddrc_mp *ddrc_mp_val,
+		 struct ddr_phy *ddr_phy_regs_val);
+
+#endif	/*__ASM_ARCH_MX7_DDR_H__ */
diff --git a/arch/arm/include/asm/arch-mx7/sys_proto.h b/arch/arm/include/asm/arch-mx7/sys_proto.h
index ca7608b..0debea5 100644
--- a/arch/arm/include/asm/arch-mx7/sys_proto.h
+++ b/arch/arm/include/asm/arch-mx7/sys_proto.h
@@ -7,3 +7,4 @@
 #include <asm/imx-common/sys_proto.h>
 
 void set_wdog_reset(struct wdog_regs *wdog);
+enum boot_device get_boot_device(void);
diff --git a/arch/arm/include/asm/arch-mxs/clock.h b/arch/arm/include/asm/arch-mxs/clock.h
index fdc5395..9785045 100644
--- a/arch/arm/include/asm/arch-mxs/clock.h
+++ b/arch/arm/include/asm/arch-mxs/clock.h
@@ -46,7 +46,7 @@ uint32_t mxc_get_clock(enum mxc_clock clk);
 void mxs_set_ioclk(enum mxs_ioclock io, uint32_t freq);
 void mxs_set_sspclk(enum mxs_sspclock ssp, uint32_t freq, int xtal);
 void mxs_set_ssp_busclock(unsigned int bus, uint32_t freq);
-void mxs_set_lcdclk(uint32_t __maybe_unused lcd_base, uint32_t freq);
+int mxs_set_lcdclk(uint32_t __maybe_unused lcd_base, uint32_t freq);
 
 /* Compatibility with the FEC Ethernet driver */
 #define	imx_get_fecclk()	mxc_get_clock(MXC_AHB_CLK)
diff --git a/arch/arm/include/asm/imx-common/regs-bch.h b/arch/arm/include/asm/imx-common/regs-bch.h
index adfbace..9b8598b 100644
--- a/arch/arm/include/asm/imx-common/regs-bch.h
+++ b/arch/arm/include/asm/imx-common/regs-bch.h
@@ -5,7 +5,7 @@
  * on behalf of DENX Software Engineering GmbH
  *
  * Based on code from LTIB:
- * Copyright 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2008-2010, 2016 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -41,6 +41,7 @@ struct mxs_bch_regs {
 	mxs_reg_32(hw_bch_dbgahbmread)
 	mxs_reg_32(hw_bch_blockname)
 	mxs_reg_32(hw_bch_version)
+	mxs_reg_32(hw_bch_debug1)
 };
 #endif
 
@@ -76,6 +77,9 @@ struct mxs_bch_regs {
 
 #define	BCH_MODE_ERASE_THRESHOLD_MASK			0xff
 #define	BCH_MODE_ERASE_THRESHOLD_OFFSET			0
+#define BCH_MODE_ERASE_THRESHOLD(v)			\
+	(((v) << BCH_MODE_ERASE_THRESHOLD_OFFSET) &	\
+	 BCH_MODE_ERASE_THRESHOLD_MASK)
 
 #define	BCH_ENCODEPTR_ADDR_MASK				0xffffffff
 #define	BCH_ENCODEPTR_ADDR_OFFSET			0
diff --git a/board/aries/m28evk/m28evk.c b/board/aries/m28evk/m28evk.c
index c990ea9..cb61e89 100644
--- a/board/aries/m28evk/m28evk.c
+++ b/board/aries/m28evk/m28evk.c
@@ -131,13 +131,15 @@ int board_eth_init(bd_t *bis)
 	udelay(10000);
 #endif
 
-	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE);
+	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE,
+				      MXS_ENET0_BASE);
 	if (ret) {
 		printf("FEC MXS: Unable to init FEC0\n");
 		return ret;
 	}
 
-	ret = fecmxc_initialize_multi(bis, 1, 3, MXS_ENET1_BASE);
+	ret = fecmxc_initialize_multi(bis, 1, 3, MXS_ENET1_BASE,
+				      MXS_ENET1_BASE);
 	if (ret) {
 		printf("FEC MXS: Unable to init FEC1\n");
 		return ret;
diff --git a/board/compulab/cl-som-am57x/cl-som-am57x.c b/board/compulab/cl-som-am57x/cl-som-am57x.c
index 389eebb..a45e5ab 100644
--- a/board/compulab/cl-som-am57x/cl-som-am57x.c
+++ b/board/compulab/cl-som-am57x/cl-som-am57x.c
@@ -11,9 +11,11 @@
 #include <common.h>
 #include <palmas.h>
 #include <usb.h>
+#include <eeprom_layout.h>
 #include <asm/gpio.h>
 #include <asm/arch/mmc_host_def.h>
 #include <asm/arch/sys_proto.h>
+
 #include "../common/common.h"
 #include "../common/eeprom.h"
 
diff --git a/board/compulab/cl-som-am57x/eth.c b/board/compulab/cl-som-am57x/eth.c
index 0c4bf91..9e3edfa 100644
--- a/board/compulab/cl-som-am57x/eth.c
+++ b/board/compulab/cl-som-am57x/eth.c
@@ -11,6 +11,7 @@
 #include <common.h>
 #include <cpsw.h>
 #include <miiphy.h>
+#include <eeprom_layout.h>
 #include <asm/gpio.h>
 #include <asm/arch/sys_proto.h>
 #include "../common/eeprom.h"
diff --git a/board/compulab/cl-som-imx7/Kconfig b/board/compulab/cl-som-imx7/Kconfig
new file mode 100644
index 0000000..6d69cf3
--- /dev/null
+++ b/board/compulab/cl-som-imx7/Kconfig
@@ -0,0 +1,28 @@
+if TARGET_CL_SOM_IMX7
+
+config SYS_BOARD
+	default "cl-som-imx7"
+
+config SYS_VENDOR
+	default "compulab"
+
+config SYS_CONFIG_NAME
+	default "cl-som-imx7"
+
+config SYS_MMC_DEV
+	int
+	default 0
+
+config SYS_USB_DEV
+	int
+	default 0
+
+config SYS_MMC_IMG_LOAD_PART
+	int
+	default 1
+
+config SYS_USB_IMG_LOAD_PART
+	int
+	default 1
+
+endif
diff --git a/board/compulab/cl-som-imx7/MAINTAINERS b/board/compulab/cl-som-imx7/MAINTAINERS
new file mode 100644
index 0000000..2b917a5
--- /dev/null
+++ b/board/compulab/cl-som-imx7/MAINTAINERS
@@ -0,0 +1,6 @@
+CL-SOM-IMX7 BOARD
+M:	Uri Mashiach <uri.mashiach@compulab.co.il>
+S:	Maintained
+F:	board/compulab/cl-som-imx7
+F:	include/configs/cl-som-imx7.h
+F:	configs/cl_som_imx7_defconfig
diff --git a/board/compulab/cl-som-imx7/Makefile b/board/compulab/cl-som-imx7/Makefile
new file mode 100644
index 0000000..bc5361a
--- /dev/null
+++ b/board/compulab/cl-som-imx7/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile
+#
+# (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+#
+# Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+#
+# SPDX-License-Identifier:     GPL-2.0+
+#
+
+obj-y := mux.o common.o
+
+ifdef CONFIG_SPL_BUILD
+obj-y  += spl.o
+else
+obj-y  += cl-som-imx7.o
+obj-$(CONFIG_VIDEO_MXS) += display.o
+endif
diff --git a/board/compulab/cl-som-imx7/cl-som-imx7.c b/board/compulab/cl-som-imx7/cl-som-imx7.c
new file mode 100644
index 0000000..61aaecc
--- /dev/null
+++ b/board/compulab/cl-som-imx7/cl-som-imx7.c
@@ -0,0 +1,693 @@
+/*
+ * U-Boot board functions for CompuLab CL-SOM-iMX7 module
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <mmc.h>
+#include <phy.h>
+#include <netdev.h>
+#include <fsl_esdhc.h>
+#include <pca953x.h>
+#include <power/pmic.h>
+#include <power/pfuze3000_pmic.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/arch-mx7/mx7-pins.h>
+#include <asm/arch-mx7/sys_proto.h>
+#include <asm/arch-mx7/clock.h>
+#include <asm/setup.h>
+#include <eeprom_layout.h>
+#include "../common/eeprom.h"
+#include "common.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int nand_enabled = 0;
+
+static uchar cl_som_am57x_eeprom_buf[CONFIG_SYS_EEPROM_SIZE];
+static uchar sb_som_am57x_eeprom_buf[CONFIG_SYS_EEPROM_SIZE];
+static struct eeprom_layout cl_som_am57x_layout;
+static struct eeprom_layout sb_som_am57x_layout;
+
+#ifdef CONFIG_SYS_I2C_MXC
+
+/* Baseboard I2C bus is initialized flag */
+int cl_som_imx7_base_i2c_init;
+
+#define I2C_PAD_CTRL		(PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+				PAD_CTL_HYS)
+
+#define CL_SOM_IMX7_GPIO_I2C2_SCL	IMX_GPIO_NR(1, 6)
+#define CL_SOM_IMX7_GPIO_I2C2_SDA	IMX_GPIO_NR(1, 7)
+
+static struct i2c_pads_info cl_som_imx7_i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO06__I2C2_SCL |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX7D_PAD_GPIO1_IO06__GPIO1_IO6 |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = CL_SOM_IMX7_GPIO_I2C2_SCL,
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO07__I2C2_SDA |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX7D_PAD_GPIO1_IO07__GPIO1_IO7 |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = CL_SOM_IMX7_GPIO_I2C2_SDA,
+	},
+};
+
+static struct i2c_pads_info cl_som_imx7_i2c_pad_info4 = {
+	.scl = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO10__I2C4_SCL |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX7D_PAD_GPIO1_IO10__GPIO1_IO10 |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 10),
+	},
+	.sda = {
+		.i2c_mode = MX7D_PAD_GPIO1_IO11__I2C4_SDA |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gpio_mode = MX7D_PAD_GPIO1_IO11__GPIO1_IO11 |
+			MUX_PAD_CTRL(I2C_PAD_CTRL),
+		.gp = IMX_GPIO_NR(1, 11),
+	},
+};
+
+/* Environment variable: base board I2C bus enable */
+#define CL_SOM_IMX7_ENV_BASE_I2C "baseboard_i2c_enable"
+
+/*
+ * cl_som_imx7_setup_i2c() - I2C  pinmux configuration.
+ */
+static void cl_som_imx7_setup_i2c0(void)
+{
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &cl_som_imx7_i2c_pad_info2);
+}
+static int cl_som_imx7_setup_i2c1(void)
+{
+	int ret;
+	char *base_i2c = getenv(CL_SOM_IMX7_ENV_BASE_I2C);
+
+	if (base_i2c && (!strcmp(base_i2c, "yes") ||
+			 !strcmp(base_i2c, "true") ||
+			 !strcmp(base_i2c, "1"))) {
+		ret = setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &cl_som_imx7_i2c_pad_info4);
+		if (ret)
+			return 0;
+		return 1;
+	}
+
+	return 0;
+}
+#else /* !CONFIG_SYS_I2C_MXC */
+static void cl_som_imx7_setup_i2c0(void) {}
+static int cl_som_imx7_setup_i2c1(void) { return 0; }
+#endif /* CONFIG_SYS_I2C_MXC */
+
+int dram_init(void)
+{
+	gd->ram_size = imx_ddr_size();
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define CL_SOM_IMX7_GPIO_USDHC3_PWR	IMX_GPIO_NR(6, 11)
+
+static struct fsl_esdhc_cfg cl_som_imx7_usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+};
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc2                    USDHC3 (eMMC)
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			cl_som_imx7_usdhc1_pads_set();
+			gpio_request(CL_SOM_IMX7_GPIO_USDHC1_CD, "usdhc1_cd");
+			cl_som_imx7_usdhc_cfg[0].sdhc_clk =
+				mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			if (nand_enabled)
+				return 0; /* nand enabled configuration */
+			/* emmc enabled configuration */
+			cl_som_imx7_usdhc3_emmc_pads_set();
+			gpio_request(CL_SOM_IMX7_GPIO_USDHC3_PWR, "usdhc3_pwr");
+			gpio_direction_output(CL_SOM_IMX7_GPIO_USDHC3_PWR, 0);
+			udelay(500);
+			gpio_direction_output(CL_SOM_IMX7_GPIO_USDHC3_PWR, 1);
+			cl_som_imx7_usdhc_cfg[1].sdhc_clk =
+				mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers "
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &cl_som_imx7_usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_FSL_ESDHC */
+
+#ifdef CONFIG_NAND_MXS
+
+#define CL_SOM_IMX7_NAND_ENABLE		IMX_GPIO_NR(6, 13)
+
+static void get_nand_enable_state(void) {
+	cl_som_imx7_nand_enable_pads_set();
+	gpio_direction_input(CL_SOM_IMX7_NAND_ENABLE);
+	mdelay(1);
+	nand_enabled = gpio_get_value(CL_SOM_IMX7_NAND_ENABLE);
+}
+
+static void cl_som_imx7_setup_gpmi_nand(void)
+{
+	get_nand_enable_state();
+	/* nand enabled configuration */
+	cl_som_imx7_gpmi_nand_pads_set();
+	set_clk_nand();
+}
+#else /* !CONFIG_NAND_MXS */
+static void cl_som_imx7_setup_gpmi_nand(void) {}
+#endif /* CONFIG_NAND_MXS */
+
+#ifdef CONFIG_FEC_MXC
+
+#define CL_SOM_IMX7_ETH1_PHY_NRST	IMX_GPIO_NR(1, 4)
+
+/*
+ * cl_som_imx7_rgmii_rework() - Ethernet PHY configuration.
+ */
+static void cl_som_imx7_rgmii_rework(struct phy_device *phydev)
+{
+	unsigned short val;
+
+	/* Ar8031 phy SmartEEE feature cause link status generates glitch,
+	 * which cause ethernet link down/up issue, so disable SmartEEE
+	 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x3);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x805d);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4003);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= ~(0x1 << 8);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* To enable AR8031 ouput a 125MHz clk from CLK_25M */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x7);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, 0x8016);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xd, 0x4007);
+
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0xe);
+	val &= 0xffe3;
+	val |= 0x18;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0xe, val);
+
+	/* introduce tx clock delay */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x5);
+	val = phy_read(phydev, MDIO_DEVAD_NONE, 0x1e);
+	val |= 0x0100;
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, val);
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	cl_som_imx7_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+/*
+ * cl_som_imx7_handle_mac_address() - set Ethernet MAC address environment.
+ *
+ * @env_var: MAC address environment variable
+ * @eeprom_bus: I2C bus of the environment EEPROM
+ * @eeprom_field_mac_addr: EEPROM field name of the MAC address 
+ *
+ * @return: 0 on success, < 0 on failure
+ */
+static int cl_som_imx7_handle_mac_address(char *env_var, uint eeprom_bus,
+					  char *eeprom_field_mac_addr)
+{
+	int ret;
+	unsigned char enetaddr[6];
+
+	ret = eth_getenv_enetaddr(env_var, enetaddr);
+	if (ret)
+		return 0;
+
+	ret = cl_eeprom_read_mac_addr(enetaddr, eeprom_bus);
+	if (ret)
+		return ret;
+
+	ret = cl_som_am57x_layout.read(&cl_som_am57x_layout,
+				      eeprom_field_mac_addr, enetaddr,
+				      sizeof(enetaddr));
+	if (ret)
+		return ret;
+
+	ret = is_valid_ethaddr(enetaddr);
+	if (!ret)
+		return -1;
+
+	return eth_setenv_enetaddr(env_var, enetaddr);
+}
+
+#define CL_SOM_IMX7_FEC_DEV_ID_PRI 0
+#define CL_SOM_IMX7_FEC_DEV_ID_SEC 1
+#define CL_SOM_IMX7_PCA953X_PHY_RST_SEC 4
+#define CL_SOM_IMX7_FEC_PHYADDR_PRI CONFIG_FEC_MXC_PHYADDR
+#define CL_SOM_IMX7_FEC_PHYADDR_SEC 1
+
+/*
+ * cl_som_imx7_eth_init_pri() - primary Ethernet interface initialization
+ *
+ * @bis: board information
+ *
+ * @return: 0 on success, < 0 on failure
+ */
+static int cl_som_imx7_eth_init_pri(bd_t *bis)
+{
+	/* set Ethernet MAC address environment */
+	cl_som_imx7_handle_mac_address("ethaddr", CONFIG_SYS_I2C_EEPROM_BUS,
+				       "1st MAC Address");
+	/* Ethernet interface pinmux configuration  */
+	cl_som_imx7_phy1_rst_pads_set();
+	cl_som_imx7_fec1_pads_set();
+	/* PHY reset */
+	gpio_request(CL_SOM_IMX7_ETH1_PHY_NRST, "eth1_phy_nrst");
+	gpio_direction_output(CL_SOM_IMX7_ETH1_PHY_NRST, 0);
+	mdelay(10);
+	gpio_set_value(CL_SOM_IMX7_ETH1_PHY_NRST, 1);
+
+	return fecmxc_initialize_multi(bis, CL_SOM_IMX7_FEC_DEV_ID_PRI,
+				       CL_SOM_IMX7_FEC_PHYADDR_PRI,
+				       IMX_FEC_BASE, IMX_FEC_BASE);
+}
+
+/*
+ * cl_som_imx7_eth_init_pri() - secondary Ethernet interface initialization
+ *
+ * @bis: board information
+ *
+ * @return: 0 on success, < 0 on failure
+ */
+static int cl_som_imx7_eth_init_sec(bd_t *bis)
+{
+	int ret;
+	u32 cpurev = get_cpu_rev();
+
+	/* i.MX7Solo include 1 Ethernet interface */
+	if (((cpurev & 0xFF000) >> 12) == MXC_CPU_MX7S)
+		return 0;
+
+	/* set Ethernet MAC address environment */
+	cl_som_imx7_handle_mac_address("eth1addr", CONFIG_SYS_I2C_EEPROM_BUS,
+				       "2nd MAC Address");
+	/* Ethernet interface pinmux configuration  */
+	cl_som_imx7_fec2_pads_set();
+	/* PHY reset */
+	ret = i2c_set_bus_num(SYS_I2C_BUS_SOM);
+	if (ret != 0) {
+		puts ("Failed to select the SOM I2C bus\n");
+		return -1;
+	}
+	ret = pca953x_set_dir(CONFIG_SYS_I2C_PCA953X_ADDR,
+			      1 << CL_SOM_IMX7_PCA953X_PHY_RST_SEC,
+			      PCA953X_DIR_OUT <<
+			      CL_SOM_IMX7_PCA953X_PHY_RST_SEC);
+	ret |= pca953x_set_val(CONFIG_SYS_I2C_PCA953X_ADDR,
+			       1 << CL_SOM_IMX7_PCA953X_PHY_RST_SEC, 0);
+	mdelay(10);
+	ret |= pca953x_set_val(CONFIG_SYS_I2C_PCA953X_ADDR,
+			       1 << CL_SOM_IMX7_PCA953X_PHY_RST_SEC,
+			       1 << CL_SOM_IMX7_PCA953X_PHY_RST_SEC);
+	if (ret != 0) {
+		puts ("Failed to reset the secondary Ethernet PHY\n");
+		return -1;
+	}
+	/* MAC initialization with the primary MDIO bus */
+	return fecmxc_initialize_multi(bis, CL_SOM_IMX7_FEC_DEV_ID_SEC,
+				       CL_SOM_IMX7_FEC_PHYADDR_SEC,
+				       ENET2_IPS_BASE_ADDR, IMX_FEC_BASE);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	ret = cl_som_imx7_eth_init_pri(bis);
+	if (ret)
+		puts ("Ethernet initialization failure: primary interface\n");
+	ret |= cl_som_imx7_eth_init_sec(bis);
+	if (ret)
+		puts ("Ethernet initialization failure: secondary interface\n");
+
+	return ret;
+}
+
+/*
+ * cl_som_imx7_setup_fec() - Ethernet MAC 1 clock configuration.
+ * - ENET1 reference clock mode select.
+ * - ENET1_TX_CLK output driver is disabled when configured for ALT1.
+ */
+static void cl_som_imx7_setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *)IOMUXC_GPR_BASE_ADDR;
+
+	/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]
+	   Use 125M anatop REF_CLK2 for ENET2, clear gpr1[14], gpr1[18] */
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1],
+			(IOMUXC_GPR_GPR1_GPR_ENET1_TX_CLK_SEL_MASK |
+			 IOMUXC_GPR_GPR1_GPR_ENET2_TX_CLK_SEL_MASK |
+			 IOMUXC_GPR_GPR1_GPR_ENET1_CLK_DIR_MASK |
+			 IOMUXC_GPR_GPR1_GPR_ENET2_CLK_DIR_MASK), 0);
+
+	set_clk_enet(ENET_125MHz);
+}
+#else /* !CONFIG_FEC_MXC */
+static void cl_som_imx7_setup_fec(void) {}
+#endif /* CONFIG_FEC_MXC */
+
+#ifdef CONFIG_SPI
+
+static void cl_som_imx7_spi_init(void)
+{
+	cl_som_imx7_espi1_pads_set();
+}
+#else /* !CONFIG_SPI */
+static void cl_som_imx7_spi_init(void) {}
+#endif /* CONFIG_SPI */
+
+#define CL_SOM_IMX7_PRODUCT_NAME_SIZE 16
+
+typedef struct {
+       char name[CL_SOM_IMX7_PRODUCT_NAME_SIZE];
+       char fdt_file[25];
+} cl_som_imx7_base_board_param;
+
+static cl_som_imx7_base_board_param cl_som_imx7_base_board_param_db[] = {
+       {"SB-SOM", "imx7d-sbc-imx7.dtb"},
+       {"SB-IOT", "imx7d-sbc-iot-imx7.dtb"},
+       {"SBC-IOT", "imx7d-sbc-iot-imx7.dtb"},
+       {"IOTG", "imx7d-sbc-iot-imx7.dtb"},
+       {"other", "imx7d-cl-som-imx7.dtb"},
+};
+
+/* CL-SOM-iMX7 base board ID */
+cl_som_imx7_base cl_som_imx7_base_id = CL_SOM_IMX7_OTHER;
+
+/*
+ * cl_som_imx7_get_baseboard_id() - determine baseboard ID.
+ * Baseboard ID determined by the base board's
+ * EEPROM filed "product name".
+ */
+static void cl_som_imx7_get_baseboard_id(void)
+{
+	int ret, i;
+	char prod_name_base[CL_SOM_IMX7_PRODUCT_NAME_SIZE];
+
+	if (sb_som_am57x_layout.data != sb_som_am57x_eeprom_buf)
+		return;
+
+	ret = sb_som_am57x_layout.read(&sb_som_am57x_layout, "Product Name",
+				       (uchar*) prod_name_base,
+				       CL_SOM_IMX7_PRODUCT_NAME_SIZE);
+
+	if (ret) {
+		prod_name_base[0] = 0;
+		printf("Failed getting base board name\n");
+	}
+
+	for (i = 0; i < CL_SOM_IMX7_OTHER; i++) {
+		if (!strncmp(prod_name_base,
+			     cl_som_imx7_base_board_param_db[i].name,
+			     CL_SOM_IMX7_PRODUCT_NAME_SIZE)) {
+			cl_som_imx7_base_id = i;
+			break;
+		}
+	}
+}
+
+#define CL_SOM_IMX7_FDT_FILE_NAME "fdtfile"
+#define CL_SOM_IMX7_BOARD_ID_DEF CL_SOM_IMX7_OTHER
+
+/*
+ * cl_som_imx7_update_dtb_name() - update device tree blob file name.
+ * Device tree file name determined base board ID
+ */
+static void cl_som_imx7_update_dtb_name(void)
+{
+	char *fdt_file = getenv(CL_SOM_IMX7_FDT_FILE_NAME);
+
+	if (fdt_file) /* Device tree blob file name was set */
+		return;
+
+	if (cl_som_imx7_base_id < CL_SOM_IMX7_OTHER)
+		setenv(CL_SOM_IMX7_FDT_FILE_NAME,
+		       cl_som_imx7_base_board_param_db[cl_som_imx7_base_id].
+		       fdt_file);
+	else
+		setenv(CL_SOM_IMX7_FDT_FILE_NAME,
+		       cl_som_imx7_base_board_param_db
+		       [CL_SOM_IMX7_BOARD_ID_DEF].fdt_file);
+}
+
+#define CL_SOM_IMX7_ENV_SERIAL "serial#"
+#define CL_SOM_IMX7_SERIAL_BUF_BIN_SIZE 12
+#define CL_SOM_IMX7_SERIAL_BUF_SIZE (2*CL_SOM_IMX7_SERIAL_BUF_BIN_SIZE+1)
+
+/*
+ * cl_som_imx7_set_serial_env() - set environment variable serial#.
+ * The serial number is read from the EEPROM of the module or the mainboard.
+ *
+ */
+static void cl_som_imx7_set_serial_env(void)
+{
+	char *serial_ptr = getenv(CL_SOM_IMX7_ENV_SERIAL);
+	uchar serial_buf_bin[CL_SOM_IMX7_SERIAL_BUF_BIN_SIZE];
+	char serial_buf[CL_SOM_IMX7_SERIAL_BUF_SIZE];
+	int leading_zero = 1;
+	int i;
+
+	if (serial_ptr) /* Serial number was set */
+		return;
+
+	/* Read serial number from the EEPROM */
+	switch (cl_som_imx7_base_id) {
+	case CL_SOM_IMX7_SB_SOM:
+		cl_som_am57x_layout.read(&cl_som_am57x_layout, "Serial Number",
+					 (uchar*) &serial_buf_bin,
+					 CL_SOM_IMX7_SERIAL_BUF_BIN_SIZE);
+		break;
+	case CL_SOM_IMX7_SB_IOT:
+	case CL_SOM_IMX7_SBC_IOT:
+	case CL_SOM_IMX7_IOTG:
+		if (sb_som_am57x_layout.data != sb_som_am57x_eeprom_buf)
+			break;
+		sb_som_am57x_layout.read(&sb_som_am57x_layout, "Serial Number",
+					 (uchar*) &serial_buf_bin,
+					 CL_SOM_IMX7_SERIAL_BUF_BIN_SIZE);
+		break;
+	default:
+		return;
+	}
+
+	memset(serial_buf, 0, CL_SOM_IMX7_SERIAL_BUF_SIZE);
+	serial_ptr = serial_buf;
+	/* Convert binary data to string */
+	for (i = 0; i < CL_SOM_IMX7_SERIAL_BUF_BIN_SIZE; i++) {
+		if (leading_zero && !serial_buf_bin[i])
+			continue;
+		if (leading_zero) {
+			sprintf(serial_ptr, "%x", serial_buf_bin[i]);
+			serial_ptr += strlen(serial_ptr);
+			leading_zero = 0;
+		}
+		else {
+			sprintf(serial_ptr, "%02x", serial_buf_bin[i]);
+			serial_ptr += 2;
+		}
+	}
+	setenv(CL_SOM_IMX7_ENV_SERIAL, serial_buf);
+}
+
+int board_early_init_f(void)
+{
+	cl_som_imx7_uart1_pads_set();
+	cl_som_imx7_usb_otg1_pads_set();
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+	cl_som_imx7_setup_i2c0();
+	cl_som_imx7_setup_gpmi_nand();
+	cl_som_imx7_setup_fec();
+	cl_som_imx7_spi_init();
+
+	return 0;
+}
+
+#ifdef CONFIG_POWER
+#define I2C_PMIC	0
+int power_init_board(void)
+{
+	struct pmic *p;
+	int ret;
+	unsigned int reg, rev_id;
+
+	ret = power_pfuze3000_init(I2C_PMIC);
+	if (ret)
+		return ret;
+
+	p = pmic_get("PFUZE3000");
+	ret = pmic_probe(p);
+	if (ret)
+		return ret;
+
+	pmic_reg_read(p, PFUZE3000_DEVICEID, &reg);
+	pmic_reg_read(p, PFUZE3000_REVID, &rev_id);
+	printf("PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n", reg, rev_id);
+
+	/* disable Low Power Mode during standby mode */
+	pmic_reg_write(p, PFUZE3000_LDOGCTL, 0x1);
+
+	return 0;
+}
+#endif /* CONFIG_POWER */
+
+/*
+ * cl_som_imx7_setup_wdog() - watchdog configuration.
+ * - Output WDOG_B signal to reset external pmic.
+ * - Suspend the watchdog timer during low-power modes.
+ */
+void cl_som_imx7_setup_wdog(void)
+{
+	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
+	cl_som_imx7_wdog_pads_set();
+	set_wdog_reset(wdog);
+	/*
+	* Do not assert internal WDOG_RESET_B_DEB(controlled by bit 4),
+	* since we use PMIC_PWRON to reset the board.
+	*/
+	clrsetbits_le16(&wdog->wcr, 0, 0x10);
+}
+
+int board_late_init(void)
+{
+	int ret;
+
+#ifdef CONFIG_VIDEO_MXS
+	ret = enable_display();
+	if (ret < 0)
+		printf("Display enable failure\n");
+#endif /* CONFIG_VIDEO_MXS */
+
+	cl_som_imx7_setup_wdog();
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	int ret;
+	char *mode;
+
+	if (IS_ENABLED(CONFIG_ARMV7_BOOT_SEC_DEFAULT))
+		mode = "secure";
+	else
+		mode = "non-secure";
+
+	printf("Board: CL-SOM-iMX7 in %s mode\n", mode);
+
+	setenv("board_name", "CL-SOM-iMX7");
+	cl_som_imx7_base_i2c_init = cl_som_imx7_setup_i2c1();
+	ret = cl_eeprom_layout_setup(&cl_som_am57x_layout,
+				     cl_som_am57x_eeprom_buf,
+				     LAYOUT_VERSION_AUTODETECT,
+				     CONFIG_SYS_I2C_EEPROM_BUS,
+				     CONFIG_SYS_I2C_EEPROM_ADDR);
+	if (ret)
+		printf("Module EEPROM layout initialization failure\n");
+	if (cl_som_imx7_base_i2c_init)
+		ret = cl_eeprom_layout_setup(&sb_som_am57x_layout,
+					     sb_som_am57x_eeprom_buf,
+					     LAYOUT_VERSION_AUTODETECT,
+					     CL_SOM_IMX7_I2C_BUS_EXT,
+					     CL_SOM_IMX7_I2C_EEPROM_EXT);
+	if (ret)
+		printf("Base board EEPROM layout initialization failure\n");
+	cl_som_imx7_get_baseboard_id();
+	cl_som_imx7_update_dtb_name();
+	cl_som_imx7_set_serial_env();
+
+	return 0;
+}
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <malloc.h>
+#include "../common/common.h"
+
+int fdt_board_adjust(void)
+{
+	int ret = 0;
+	u32 cpurev = get_cpu_rev();
+
+	/* Disable features not supported by i.MX7Solo */
+	if (((cpurev & 0xFF000) >> 12) == MXC_CPU_MX7S) {
+		/* FEC2 with PHY */
+		fdt_node_disable("/soc/aips-bus@30800000/ethernet@30bf0000");
+		fdt_node_disable("/soc/aips-bus@30800000/ethernet@30be0000/mdio/ethernet-phy@1");
+		/* PCIe */
+		fdt_node_disable("/soc/pcie@0x33800000");
+		/* USB Host HSIC */
+		fdt_node_disable("/soc/aips-bus@30800000/usb@30b20000");
+	}
+
+	/* Main storage setup */
+	if (nand_enabled) {
+		/* Enable GPMI and disable eMMC */
+		fdt_node_enable("/soc/gpmi-nand@33002000");
+		fdt_node_disable("/soc/aips-bus@30800000/usdhc@30b60000");
+	} else {
+		/* Enable eMMC and disable GPMI */
+		fdt_node_enable("/soc/aips-bus@30800000/usdhc@30b60000");
+		fdt_node_disable("/soc/gpmi-nand@33002000");
+	}
+
+#ifdef CONFIG_VIDEO
+	/* Update display timing parameters */
+	ret = fdt_board_adjust_display();
+#endif /* CONFIG_VIDEO */
+
+	return ret;
+}
+#endif /* CONFIG_OF_BOARD_SETUP */
diff --git a/board/compulab/cl-som-imx7/common.c b/board/compulab/cl-som-imx7/common.c
new file mode 100644
index 0000000..1f90c62
--- /dev/null
+++ b/board/compulab/cl-som-imx7/common.c
@@ -0,0 +1,46 @@
+/*
+ * SPL/U-Boot common functions for CompuLab CL-SOM-iMX7 module
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <asm-generic/gpio.h>
+#include "common.h"
+
+#ifdef CONFIG_SPI
+
+#define CL_SOM_IMX7_GPIO_SPI_CS	IMX_GPIO_NR(4, 19)
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return CL_SOM_IMX7_GPIO_SPI_CS;
+}
+
+#endif /* CONFIG_SPI */
+
+#ifdef CONFIG_FSL_ESDHC
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(CL_SOM_IMX7_GPIO_USDHC1_CD);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = 1; /* Assume uSDHC3 emmc is always present */
+		break;
+	}
+
+	return ret;
+}
+
+#endif /* CONFIG_FSL_ESDHC */
diff --git a/board/compulab/cl-som-imx7/common.h b/board/compulab/cl-som-imx7/common.h
new file mode 100644
index 0000000..33c216b
--- /dev/null
+++ b/board/compulab/cl-som-imx7/common.h
@@ -0,0 +1,61 @@
+/*
+ * SPL/U-Boot common header file for CompuLab CL-SOM-iMX7 module
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define PADS_SET_PROT(pads_array) void cl_som_imx7_##pads_array##_set(void);
+
+#ifdef CONFIG_FSL_ESDHC
+#define CL_SOM_IMX7_GPIO_USDHC1_CD	IMX_GPIO_NR(5, 0)
+PADS_SET_PROT(usdhc1_pads)
+#endif /* CONFIG_FSL_ESDHC */
+PADS_SET_PROT(uart1_pads)
+#ifdef CONFIG_SPI
+PADS_SET_PROT(espi1_pads)
+#endif /* CONFIG_SPI */
+
+PADS_SET_PROT(wdog_pads)
+
+#ifndef CONFIG_SPL_BUILD
+#ifdef CONFIG_FSL_ESDHC
+PADS_SET_PROT(usdhc3_emmc_pads)
+#endif /* CONFIG_FSL_ESDHC */
+#ifdef CONFIG_FEC_MXC
+PADS_SET_PROT(phy1_rst_pads)
+PADS_SET_PROT(fec1_pads)
+PADS_SET_PROT(fec2_pads)
+#endif /* CONFIG_FEC_MXC */
+PADS_SET_PROT(usb_otg1_pads)
+PADS_SET_PROT(wdog_pads)
+#ifdef CONFIG_NAND_MXS
+PADS_SET_PROT(gpmi_nand_pads)
+PADS_SET_PROT(nand_enable_pads)
+#endif /* CONFIG_NAND_MXS */
+#ifdef CONFIG_SYS_I2C_MXC
+extern int cl_som_imx7_base_i2c_init;
+#endif /* CONFIG_SYS_I2C_MXC */
+
+/* CL-SOM-iMX7 base board ID */
+typedef enum {
+       CL_SOM_IMX7_SB_SOM,
+       CL_SOM_IMX7_SB_IOT,
+       CL_SOM_IMX7_SBC_IOT,
+       CL_SOM_IMX7_IOTG,
+       CL_SOM_IMX7_OTHER,
+} cl_som_imx7_base;
+
+extern cl_som_imx7_base cl_som_imx7_base_id;
+
+#ifdef CONFIG_VIDEO_MXS
+int enable_display(void);
+int fdt_board_adjust_display(void);
+PADS_SET_PROT(lcd_pads)
+PADS_SET_PROT(lcd_control_pads)
+#endif /* CONFIG_VIDEO_MXS */
+
+#endif /* !CONFIG_SPL_BUILD */
diff --git a/board/compulab/cl-som-imx7/display.c b/board/compulab/cl-som-imx7/display.c
new file mode 100644
index 0000000..9e42502
--- /dev/null
+++ b/board/compulab/cl-som-imx7/display.c
@@ -0,0 +1,567 @@
+/*
+ * Display configuration for the CompuLab CL-SOM-iMX7 board
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://compulab.com/
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <search.h>
+#include <env_callback.h>
+#include "../common/common.h"
+#include <asm/arch/mx7-pins.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <linux/fb.h>
+#include <i2c.h>
+#include <pca953x.h>
+#include <splash.h>
+#include "common.h"
+
+/* GPIO extender LCD enable bit */
+#define CONFIG_SYS_I2C_PCA953X_LCD_ENA	14
+/* The TFP410 address */
+#define CONFIG_SYS_TFP410_ADDR 0x39
+/* The TFP410 registers */
+#define TFP410_REG_DEV_ID_L 0x02
+#define TFP410_REG_DEV_ID_H 0x03
+#define TFP410_REG_CTL_1_MODE 0x08
+#define TFP410_REG_CTL_2_MODE 0x09
+#define TFP410_REG_CTL_3_MODE 0x0A
+/* LCD backlight GPIO */
+#define GPIO_LCD_LIGHT IMX_GPIO_NR(1, 2)
+
+#define FDT_TIMING_DVI "/soc/aips-bus@30400000/lcdif@30730000/display/display-timings/dvi"
+#define FDT_NODE_REG_DVI "/regulators/dvi_en_3v3"
+#define FDT_NODE_REG_LCD "/regulators/lcd_nstby_3v3"
+#define FLIP_32B(val) ((val>>24)&0xff) | ((val<<8)&0xff0000) | ((val>>8)&0xff00) | ((val<<24)&0xff000000)
+
+/* Display type code */
+typedef enum {
+	DISP_DVI,
+	DISP_LCD,
+	DISP_NONE,
+} display_type;
+
+/* Display parameters preset */
+typedef enum {
+	PRSET_LCD_KD050C,
+	PRSET_DVI_1280x720,
+	PRSET_DVI_1024X768,
+	PRSET_DVI_1280X1024,
+	PRSET_DVI_1920x1080,
+	PRSET_NONE,
+} display_preset;
+
+/* Doisplay parameters */
+struct disp_param {
+	char* del_node;
+	struct fb_videomode timings;
+};
+
+static struct disp_param dispparams[] = {
+	{/* PRSET_LCD_KD050C */
+		.del_node = FDT_NODE_REG_DVI,
+		.timings = {
+			.refresh	= 29580000,
+			.pixclock	= 29500,
+			.xres		= 800,
+			.left_margin	= 1,
+			.right_margin	= 16,
+			.hsync_len	= 80,
+			.yres		= 480,
+			.upper_margin	= 13,
+			.lower_margin	= 16,
+			.vsync_len	= 16,
+		}
+	},
+	{/* PRSET_DVI_1280x720 */
+		.del_node = FDT_NODE_REG_LCD,
+		.timings = {
+			.refresh	= 74250000,
+			.pixclock	= 13468,
+			.xres		= 1280,
+			.left_margin	= 220,
+			.right_margin	= 110,
+			.hsync_len	= 40,
+			.yres		= 720,
+			.upper_margin	= 20,
+			.lower_margin	= 5,
+			.vsync_len	= 5,
+		}
+	},
+	{/* PRSET_DVI_1024X768 */
+		.del_node = FDT_NODE_REG_LCD,
+		.timings = {
+			.refresh	= 65000000,
+			.pixclock	= 15384,
+			.xres		= 1024,
+			.left_margin	= 168,
+			.right_margin	= 8,
+			.hsync_len	= 144,
+			.yres		= 768,
+			.upper_margin	= 29,
+			.lower_margin	= 3,
+			.vsync_len	= 4,
+		}
+	},
+	{/* PRSET_DVI_1280X1024 */
+		.del_node = FDT_NODE_REG_LCD,
+		.timings = {
+			.refresh	= 110000000,
+			.pixclock	= 9090,
+			.xres		= 1280,
+			.left_margin	= 200,
+			.right_margin	= 48,
+			.hsync_len	= 184,
+			.yres		= 1024,
+			.upper_margin	= 26,
+			.lower_margin	= 1,
+			.vsync_len	= 3,
+		}
+	},
+	{/* PRSET_DVI_1920x1080 */
+		.del_node = FDT_NODE_REG_LCD,
+		.timings = {
+			.refresh	= 148500000,
+			.pixclock	= 6734,
+			.xres           = 1920,
+			.left_margin    = 80,
+			.right_margin   = 48,
+			.hsync_len      = 32,
+			.yres           = 1080,
+			.upper_margin   = 26,
+			.lower_margin   = 3,
+			.vsync_len      = 6,
+		}
+	},
+};
+
+/* Selected display preset ID */
+static display_preset selected_preset = PRSET_NONE;
+/* Selected display type */
+static display_type disp_type = DISP_NONE;
+
+#define TFP410_ID_H 0x00
+#define TFP410_ID_L 0x06
+
+/*
+ * tfp410_validate() - TFP410 chip validation.
+ * - validate chip device ID.
+ *
+ * Returns -1 on read failure, 1 on validation failure 0 on success.
+ */
+static int tfp410_validate(void)
+{
+	uchar buf;
+	int ret;
+
+	/* check version */
+	ret = i2c_read(CONFIG_SYS_TFP410_ADDR, TFP410_REG_DEV_ID_L, 1, &buf, 1);
+	if (ret != 0) {
+		puts ("TFP410 validation read failure.\n");
+		return -1;
+	}
+	if (buf != TFP410_ID_L)
+		return 1;
+	ret = i2c_read(CONFIG_SYS_TFP410_ADDR, TFP410_REG_DEV_ID_H, 1, &buf, 1);
+	if (ret != 0) {
+		puts ("TFP410 validation read failure.\n");
+		return -1;
+	}
+	if (buf != TFP410_ID_H)
+		return 1;
+
+	return 0;
+}
+
+/*
+ * dvi_on() - turn on the DVI display.
+ * - Enable the TFP410 chip.
+ *
+ * Returns -1 on failure, 0 on success.
+ */
+static int dvi_on(void)
+{
+	uchar buf;
+	int ret = -1;
+
+	if (!cl_som_imx7_base_i2c_init)
+	  return 0;
+
+	ret = i2c_set_bus_num(CL_SOM_IMX7_I2C_BUS_EXT);
+	if (ret != 0) {
+		puts ("Failed to select the external I2C bus.\n");
+		return -1;
+	}
+	ret = tfp410_validate();
+	if (ret != 0)
+		return 0;
+	/* Enable the TFP410 chip - RGP to DVI converter */
+	buf = 0x35;
+	ret = i2c_write(CONFIG_SYS_TFP410_ADDR,
+			TFP410_REG_CTL_1_MODE, 1, &buf, 1);
+	buf = 0xa6;
+	ret |= i2c_write(CONFIG_SYS_TFP410_ADDR,
+			 TFP410_REG_CTL_2_MODE, 1, &buf, 1);
+	buf = 0x10;
+	ret |= i2c_write(CONFIG_SYS_TFP410_ADDR,
+			 TFP410_REG_CTL_3_MODE, 1, &buf, 1);
+	if (ret != 0) {
+		puts ("TFP410 chip enable failure.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * lcd_on() - turn on the LCD display.
+ * - Turn on the LCD backlight.
+ * - Enable LCD GPIO.
+ *
+ * Returns -1 on failure, 0 on success.
+ */
+static int lcd_on(void)
+{
+	int ret = -1;
+
+	if (cl_som_imx7_base_id != CL_SOM_IMX7_SB_SOM)
+		return 0;
+
+	/* Turn on the LCD backlight */
+	ret = gpio_direction_output(GPIO_LCD_LIGHT , 1);
+	if (ret != 0) {
+		puts ("Failed to turn on the LCD backlight.\n");
+		return -1;
+	}
+	ret = i2c_set_bus_num(CL_SOM_IMX7_I2C_BUS_EXT);
+	if (ret != 0) {
+		puts ("Failed to select the external I2C bus.\n");
+		return -1;
+	}
+	/* Enable LCD GPIO */
+	ret = pca953x_set_dir(CONFIG_SYS_I2C_PCA953X_ADDR,
+			1 << CONFIG_SYS_I2C_PCA953X_LCD_ENA,
+			PCA953X_DIR_OUT << CONFIG_SYS_I2C_PCA953X_LCD_ENA);
+	ret |= pca953x_set_val(CONFIG_SYS_I2C_PCA953X_ADDR,
+			1 << CONFIG_SYS_I2C_PCA953X_LCD_ENA,
+			1 << CONFIG_SYS_I2C_PCA953X_LCD_ENA);
+	if (ret != 0) {
+		puts ("LCD GPIO enable failure.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * dvi_off() - turn off the DVI display.
+ * - Disable the TFP410 chip.
+ *
+ * Returns -1 on failure, 0 on success.
+ */
+static int dvi_off(void)
+{
+	uchar buf;
+	int ret = -1;
+
+	if (!cl_som_imx7_base_i2c_init)
+	  return 0;
+
+	ret = i2c_set_bus_num(CL_SOM_IMX7_I2C_BUS_EXT);
+	if (ret != 0) {
+		puts ("Failed to select the external I2C bus.\n");
+		return -1;
+	}
+	ret = tfp410_validate();
+	if (ret != 0)
+		return 0;
+	/* Disable the TFP410 chip - RGP to DVI converter */
+	buf = 0xfe;
+	ret = i2c_write(CONFIG_SYS_TFP410_ADDR,
+			TFP410_REG_CTL_1_MODE, 1, &buf, 1);
+	if (ret != 0) {
+		puts ("TFP410 chip disable failure.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * lcd_off() - turn off the LCD display.
+ * - Turn off the LCD backlight.
+ * - Disable LCD GPIO.
+ *
+ * Returns -1 on failure, 0 on success.
+ */
+static int lcd_off(void)
+{
+	int ret = -1;
+
+	if (cl_som_imx7_base_id != CL_SOM_IMX7_SB_SOM)
+		return 0;
+
+	/* Turn off the LCD backlight */
+	ret = gpio_direction_output(GPIO_LCD_LIGHT , 0);
+	if (ret != 0) {
+		puts ("Failed to turn off the LCD backlight.\n");
+		return -1;
+	}
+	/* Disable LCD GPIO */
+	ret |= pca953x_set_dir(CONFIG_SYS_I2C_PCA953X_ADDR,
+			1 << CONFIG_SYS_I2C_PCA953X_LCD_ENA,
+			PCA953X_DIR_OUT << CONFIG_SYS_I2C_PCA953X_LCD_ENA);
+	ret |= pca953x_set_val(CONFIG_SYS_I2C_PCA953X_ADDR,
+			1 << CONFIG_SYS_I2C_PCA953X_LCD_ENA, 0);
+	if (ret != 0) {
+		puts ("LCD GPIO disable failure.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * set_preset() - apply specific display preset.
+ * The parameters are used by Freescale videomode module.
+ *
+ * Returns -1 on failure, display type code on success.
+ */
+static display_type set_preset(void)
+{
+	int ret = -1;
+	display_type disp_type = DISP_DVI;
+	char videomod_buf[100];
+
+	if ((selected_preset < 0) || (selected_preset >= PRSET_NONE))
+		return DISP_NONE;
+
+	sprintf(videomod_buf,
+		"video=ctfb:x:%u,y:%u,depth:24,pclk:%u,le:%u,ri:%u,up:%u," \
+		"lo:%u,hs:%u,vs:%u,sync:0,vmode:0",
+		dispparams[selected_preset].timings.xres,
+		dispparams[selected_preset].timings.yres,
+		dispparams[selected_preset].timings.pixclock,
+		dispparams[selected_preset].timings.left_margin,
+		dispparams[selected_preset].timings.right_margin,
+		dispparams[selected_preset].timings.upper_margin,
+		dispparams[selected_preset].timings.lower_margin,
+		dispparams[selected_preset].timings.hsync_len,
+		dispparams[selected_preset].timings.vsync_len);
+	ret = setenv("videomode", videomod_buf);
+	if (ret)
+		return -1;
+
+	if (selected_preset == PRSET_LCD_KD050C)
+		disp_type = DISP_LCD;
+
+	return disp_type;
+}
+
+/*
+ * env_parse_displaytype() - parse environment parameter.
+ * - Determine display type.
+ * - Set display timing in environment parameter "videomode".
+ *
+ * @displaytype: The environment variable containing the display parameters.
+ * Returns negative value on failure, display type code on success.
+ */
+static display_type env_parse_displaytype(char *disp_type)
+{
+	if ((!strcmp(disp_type, "dvi1024x768")) ||
+	    (!strcmp(disp_type, "dvi"))) {
+		selected_preset = PRSET_DVI_1024X768;
+	}
+	else if (!strcmp(disp_type, "dvi1920x1080"))
+		selected_preset = PRSET_DVI_1920x1080;
+	else if (!strcmp(disp_type, "dvi1280x1024"))
+		selected_preset = PRSET_DVI_1280X1024;
+	else if (!strcmp(disp_type, "dvi1280x720"))
+		selected_preset = PRSET_DVI_1280x720;
+	else if (!strcmp(disp_type, "lcd_KD050C"))
+		selected_preset = PRSET_LCD_KD050C;
+	return set_preset();
+}
+
+/* Enable the appropriate display */
+/*
+ * enable_display() - enable specific display type.
+ *
+ * Returns negative value on failure, 0 on success.
+ */
+int enable_display(void)
+{
+	int ret = 0;
+	char *stdout_env = getenv("stdout");
+
+	switch (disp_type) {
+	case DISP_DVI:
+		ret = lcd_off();
+		ret |= dvi_on();
+		break;
+	case DISP_LCD:
+		ret = dvi_off();
+		ret |= lcd_on();
+		break;
+	default:
+		break;
+	}
+
+	/*
+	 * Update stdout and enderr environment parameters according to the
+	 * baseboard type
+	 */
+	if (stdout_env) /* stdout was set */
+		return 0;
+	if ((cl_som_imx7_base_id ==  CL_SOM_IMX7_SB_IOT) ||
+	    (cl_som_imx7_base_id ==  CL_SOM_IMX7_SBC_IOT) ||
+	    (cl_som_imx7_base_id ==  CL_SOM_IMX7_IOTG)) {
+		setenv("stdout", "serial,vga");
+		setenv("stderr", "serial,vga");
+	}
+	else {
+		setenv("stdout", "serial");
+		setenv("stderr", "serial");
+	}
+
+	return ret;
+}
+
+/*
+ * setup_display() - set display signal MUX, enable display, set timing.
+ * The function is called from drv_video_init @ cfb_console.c
+ * Returns negative value on failure, 0 on success.
+ */
+int board_video_skip(void)
+{
+	int ret;
+	char *displaytype = getenv("displaytype");
+
+	cl_som_imx7_lcd_pads_set();
+	if (cl_som_imx7_base_id == CL_SOM_IMX7_SB_SOM)
+		cl_som_imx7_lcd_control_pads_set();
+
+	disp_type = env_parse_displaytype(displaytype);
+	if (disp_type < 0) {
+		printf("displaytype parsing failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+/*
+ * on_displaytype() - callback function for the environment "displaytype"
+ *
+ * @name: environment name
+ * @value: environment value
+ * @op: operation - create, update, delete.
+ * Returns negative value on failure, 0 on success.
+ */
+static int on_displaytype(const char *name, const char *value, enum env_op op,
+			  int flags)
+{
+	int ret;
+
+	if (op != env_op_overwrite)
+		return 0;
+
+	ret = env_parse_displaytype((char*) value);
+	if (ret < 0) {
+		printf("displaytype parsing failure\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+U_BOOT_ENV_CALLBACK(displaytype, on_displaytype);
+
+#ifdef CONFIG_SPLASH_SCREEN
+/* Splash screen sources options */
+static struct splash_location cl_som_imx7_splash_locations[] = {
+	{
+		.name = "sf",
+		.storage = SPLASH_STORAGE_SF,
+		.flags = SPLASH_STORAGE_RAW,
+		.offset = 0x100000,
+	},
+	{
+		.name = "mmc_fs",
+		.storage = SPLASH_STORAGE_MMC,
+		.flags = SPLASH_STORAGE_FS,
+		.devpart = "0:1",
+	},
+	{
+		.name = "usb_fs",
+		.storage = SPLASH_STORAGE_USB,
+		.flags = SPLASH_STORAGE_FS,
+		.devpart = "0:1",
+	},
+};
+
+/*
+ * splash_screen_prepare() - load splash screen image to RAM.
+ *
+ * Returns -1 on failure, 0 on success.
+ */
+int splash_screen_prepare(void)
+{
+	int ret = splash_source_load(cl_som_imx7_splash_locations,
+				     ARRAY_SIZE(cl_som_imx7_splash_locations));
+
+	if (!ret) {/* Splash screen loaded - prevent VGA console */
+		setenv("stdout", "serial");
+	}
+
+	return ret;
+}
+#endif /* CONFIG_SPLASH_SCREEN */
+
+/*
+ * fdt_board_adjust_display() - update device tree.
+ * * Updating device tree with display timing parameters.
+ * * Disable the regulator of the not active display.
+ * Returns -1 on failure, 0 on success.
+ */
+int fdt_board_adjust_display(void)
+{
+	u32 flip_val;
+	int ret;
+
+	if ((selected_preset < 0) || (selected_preset >= PRSET_NONE))
+		return 0;
+
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.refresh);
+	ret = fdt_prop_set(FDT_TIMING_DVI, "clock-frequency", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.xres);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "hactive", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.yres);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "vactive", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.left_margin);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "hback-porch", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.right_margin);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "hfront-porch", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.upper_margin);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "vback-porch", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.lower_margin);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "vfront-porch", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.hsync_len);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "hsync-len", &flip_val, 4, 0);
+	flip_val = FLIP_32B(dispparams[selected_preset].timings.vsync_len);
+	ret |= fdt_prop_set(FDT_TIMING_DVI, "vsync-len", &flip_val, 4, 0);
+	if (ret) {
+		printf("Failed updating device tree with display \
+			timing parameters\n");
+		return -1;
+	}
+	fdt_prop_del(dispparams[selected_preset].del_node,
+		     "regulator-always-on");
+
+	return 0;
+}
diff --git a/board/compulab/cl-som-imx7/mux.c b/board/compulab/cl-som-imx7/mux.c
new file mode 100644
index 0000000..b976310
--- /dev/null
+++ b/board/compulab/cl-som-imx7/mux.c
@@ -0,0 +1,241 @@
+/*
+ * SPL/U-Boot mux functions for CompuLab CL-SOM-iMX7 module
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/arch-mx7/mx7-pins.h>
+
+#define PADS_SET(pads_array)						       \
+void cl_som_imx7_##pads_array##_set(void)				       \
+{									       \
+	imx_iomux_v3_setup_multiple_pads(pads_array, ARRAY_SIZE(pads_array));  \
+}
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC_PAD_CTRL		(PAD_CTL_DSE_3P3V_32OHM | PAD_CTL_SRE_SLOW | \
+				PAD_CTL_HYS | PAD_CTL_PUE | \
+				PAD_CTL_PUS_PU47KOHM)
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX7D_PAD_SD1_CLK__SD1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_CMD__SD1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD1_DATA3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD1_CD_B__GPIO5_IO0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+PADS_SET(usdhc1_pads)
+
+#endif /* CONFIG_FSL_ESDHC */
+
+#define UART_PAD_CTRL		(PAD_CTL_DSE_3P3V_49OHM | \
+				PAD_CTL_PUS_PU100KOHM | PAD_CTL_HYS)
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX7D_PAD_UART1_TX_DATA__UART1_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX7D_PAD_UART1_RX_DATA__UART1_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+PADS_SET(uart1_pads)
+
+#ifdef CONFIG_SPI
+
+#define SPI_PAD_CTRL	(PAD_CTL_HYS | PAD_CTL_SRE_SLOW | \
+			PAD_CTL_DSE_3P3V_32OHM)
+
+#define GPIO_PAD_CTRL	(PAD_CTL_PUS_PU5KOHM | PAD_CTL_PUE | \
+			PAD_CTL_SRE_SLOW)
+
+static iomux_v3_cfg_t const espi1_pads[] = {
+	MX7D_PAD_ECSPI1_SCLK__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MISO__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_MOSI__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX7D_PAD_ECSPI1_SS0__GPIO4_IO19 | MUX_PAD_CTRL(GPIO_PAD_CTRL),
+};
+
+PADS_SET(espi1_pads)
+
+#endif /* CONFIG_SPI */
+
+static iomux_v3_cfg_t const wdog_pads[] = {
+	MX7D_PAD_GPIO1_IO00__WDOG1_WDOG_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+PADS_SET(wdog_pads)
+
+#ifndef CONFIG_SPL_BUILD
+
+#ifdef CONFIG_FSL_ESDHC
+
+static iomux_v3_cfg_t const usdhc3_emmc_pads[] = {
+	MX7D_PAD_SD3_CLK__SD3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__SD3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__SD3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__SD3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__SD3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__SD3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__SD3_STROBE	 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	MX7D_PAD_SD3_RESET_B__GPIO6_IO11 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+PADS_SET(usdhc3_emmc_pads)
+
+#endif /* CONFIG_FSL_ESDHC */
+
+#ifdef CONFIG_FEC_MXC
+
+#define ENET_PAD_CTRL		(PAD_CTL_PUS_PD100KOHM | PAD_CTL_DSE_3P3V_49OHM)
+#define ENET_PAD_CTRL_MII	(PAD_CTL_PUS_PU5KOHM)
+
+static iomux_v3_cfg_t const phy1_rst_pads[] = {
+	/* PHY1 RST */
+	MX7D_PAD_GPIO1_IO04__GPIO1_IO4	| MUX_PAD_CTRL(GPIO_PAD_CTRL),
+};
+
+PADS_SET(phy1_rst_pads)
+
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX7D_PAD_ENET1_RGMII_RX_CTL__ENET1_RGMII_RX_CTL |
+	MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD0__ENET1_RGMII_RD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD1__ENET1_RGMII_RD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD2__ENET1_RGMII_RD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RD3__ENET1_RGMII_RD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_RXC__ENET1_RGMII_RXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TX_CTL__ENET1_RGMII_TX_CTL |
+	MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD0__ENET1_RGMII_TD0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD1__ENET1_RGMII_TD1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD2__ENET1_RGMII_TD2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TD3__ENET1_RGMII_TD3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_ENET1_RGMII_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_SD2_CD_B__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+	MX7D_PAD_SD2_WP__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL_MII),
+};
+
+PADS_SET(fec1_pads)
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX7D_PAD_EPDC_SDCE0__ENET2_RGMII_RX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCLK__ENET2_RGMII_RD0    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDLE__ENET2_RGMII_RD1     | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDOE__ENET2_RGMII_RD2     | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDSHR__ENET2_RGMII_RD3    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE1__ENET2_RGMII_RXC    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDRL__ENET2_RGMII_TX_CTL  | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE2__ENET2_RGMII_TD0    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_SDCE3__ENET2_RGMII_TD1    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDCLK__ENET2_RGMII_TD2    | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDOE__ENET2_RGMII_TD3     | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX7D_PAD_EPDC_GDSP__ENET2_RGMII_TXC     | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+PADS_SET(fec2_pads)
+
+#endif /* CONFIG_FEC_MXC */
+
+static iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX7D_PAD_GPIO1_IO05__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+PADS_SET(usb_otg1_pads)
+
+#ifdef CONFIG_NAND_MXS
+
+#define GPMI_PAD_CTRL		(PAD_CTL_DSE_3P3V_49OHM | PAD_CTL_PUE | \
+				PAD_CTL_PUS_PU100KOHM | PAD_CTL_SRE_SLOW | \
+				PAD_CTL_HYS)
+
+static iomux_v3_cfg_t const gpmi_nand_pads[] = {
+	MX7D_PAD_SD3_CLK__NAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_CMD__NAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA0__NAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA1__NAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA2__NAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA3__NAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA4__NAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA5__NAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA6__NAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_DATA7__NAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_STROBE__NAND_RE_B   | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SD3_RESET_B__NAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_BCLK__NAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SAI1_TX_DATA__NAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+	MX7D_PAD_SAI1_MCLK__NAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL),
+};
+
+PADS_SET(gpmi_nand_pads)
+
+static iomux_v3_cfg_t const nand_enable_pads[] = {
+	MX7D_PAD_SAI1_TX_BCLK__GPIO6_IO13 | MUX_PAD_CTRL(0),
+};
+
+PADS_SET(nand_enable_pads)
+
+#endif /* CONFIG_NAND_MXS */
+
+#ifdef CONFIG_VIDEO_MXS
+
+#define LCD_PAD_CTRL		(PAD_CTL_HYS | PAD_CTL_PUS_PU100KOHM |	\
+				PAD_CTL_DSE_3P3V_49OHM)
+
+/* RGB signals MUX */
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX7D_PAD_EPDC_DATA00__LCD_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA01__LCD_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA03__LCD_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA02__LCD_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA00__LCD_DATA0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA01__LCD_DATA1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA02__LCD_DATA2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA03__LCD_DATA3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA04__LCD_DATA4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA05__LCD_DATA5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA06__LCD_DATA6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA07__LCD_DATA7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA08__LCD_DATA8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA09__LCD_DATA9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA10__LCD_DATA10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA11__LCD_DATA11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA12__LCD_DATA12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA13__LCD_DATA13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA14__LCD_DATA14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_EPDC_DATA15__LCD_DATA15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA16__LCD_DATA16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA17__LCD_DATA17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA18__LCD_DATA18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA19__LCD_DATA19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA20__LCD_DATA20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA21__LCD_DATA21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA22__LCD_DATA22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX7D_PAD_LCD_DATA23__LCD_DATA23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+};
+
+PADS_SET(lcd_pads)
+
+static iomux_v3_cfg_t const lcd_control_pads[] = {
+	/* LCD backlight */
+	MX7D_PAD_GPIO1_IO02__GPIO1_IO2 | MUX_PAD_CTRL(GPIO_PAD_CTRL),
+};
+
+PADS_SET(lcd_control_pads)
+
+#endif /* CONFIG_VIDEO_MXS */
+
+#endif /* !CONFIG_SPL_BUILD */
diff --git a/board/compulab/cl-som-imx7/spl.c b/board/compulab/cl-som-imx7/spl.c
new file mode 100644
index 0000000..f4ffc97
--- /dev/null
+++ b/board/compulab/cl-som-imx7/spl.c
@@ -0,0 +1,204 @@
+/*
+ * SPL board functions for CompuLab CL-SOM-iMX7 module
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <spl.h>
+#include <fsl_esdhc.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/arch-mx7/mx7-pins.h>
+#include <asm/arch-mx7/clock.h>
+#include <asm/arch-mx7/mx7-ddr.h>
+#include "common.h"
+
+#ifdef CONFIG_FSL_ESDHC
+
+static struct fsl_esdhc_cfg cl_som_imx7_spl_usdhc_cfg = {
+	USDHC1_BASE_ADDR, 0, 4};
+
+int board_mmc_init(bd_t *bis)
+{
+	cl_som_imx7_usdhc1_pads_set();
+	cl_som_imx7_spl_usdhc_cfg.sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+	return fsl_esdhc_initialize(bis, &cl_som_imx7_spl_usdhc_cfg);
+}
+
+#endif /* CONFIG_FSL_ESDHC */
+
+static iomux_v3_cfg_t const led_pads[] = {
+	MX7D_PAD_SAI1_TX_SYNC__GPIO6_IO14 | MUX_PAD_CTRL(PAD_CTL_PUS_PU5KOHM |
+		PAD_CTL_PUE | PAD_CTL_SRE_SLOW)
+};
+
+static struct ddrc cl_som_imx7_spl_ddrc_regs_val = {
+	.init1		= 0x00690000,
+	.init0		= 0x00020083,
+	.init3		= 0x09300004,
+	.init4		= 0x04080000,
+	.init5		= 0x00100004,
+	.rankctl	= 0x0000033F,
+	.dramtmg1	= 0x0007020E,
+	.dramtmg2	= 0x03040407,
+	.dramtmg3	= 0x00002006,
+	.dramtmg4	= 0x04020305,
+	.dramtmg5	= 0x03030202,
+	.dramtmg8	= 0x00000803,
+	.zqctl0		= 0x00810021,
+	.dfitmg0	= 0x02098204,
+	.dfitmg1	= 0x00030303,
+	.dfiupd0	= 0x80400003,
+	.dfiupd1	= 0x00100020,
+	.dfiupd2	= 0x80100004,
+	.addrmap4	= 0x00000F0F,
+	.odtcfg		= 0x06000604,
+	.odtmap		= 0x00000001,
+};
+
+static struct ddrc_mp cl_som_imx7_spl_ddrc_mp_val = {
+	.pctrl_0	= 0x00000001,
+};
+
+static struct ddr_phy cl_som_imx7_spl_ddr_phy_regs_val = {
+	.phy_con0	= 0x17420F40,
+	.phy_con1	= 0x10210100,
+	.phy_con4	= 0x00060807,
+	.mdll_con0	= 0x1010007E,
+	.drvds_con0	= 0x00000D6E,
+	.cmd_sdll_con0	= 0x00000010,
+	.offset_lp_con0	= 0x0000000F,
+};
+
+static int cl_som_imx7_spl_dram_cfg_size(u32 ram_size)
+{
+	switch (ram_size) {
+	case SZ_256M:
+		cl_som_imx7_spl_ddrc_regs_val.mstr		= 0x01041001;
+		cl_som_imx7_spl_ddrc_regs_val.rfshtmg		= 0x00400046;
+		cl_som_imx7_spl_ddrc_regs_val.dramtmg0		= 0x090E1109;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap0		= 0x00000014;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap1		= 0x00151515;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap5		= 0x03030303;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap6		= 0x0F0F0303;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_rd_con0	= 0x0C0C0C0C;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_wr_con0	= 0x04040404;
+		break;
+	case SZ_512M:
+		cl_som_imx7_spl_ddrc_regs_val.mstr		= 0x01040001;
+		cl_som_imx7_spl_ddrc_regs_val.rfshtmg		= 0x00400046;
+		cl_som_imx7_spl_ddrc_regs_val.dramtmg0		= 0x090E1109;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap0		= 0x00000015;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap1		= 0x00161616;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap5		= 0x04040404;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap6		= 0x0F0F0404;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_rd_con0	= 0x0C0C0C0C;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_wr_con0	= 0x04040404;
+		break;
+	case SZ_1G:
+		cl_som_imx7_spl_ddrc_regs_val.mstr		= 0x01040001;
+		cl_som_imx7_spl_ddrc_regs_val.rfshtmg		= 0x00400046;
+		cl_som_imx7_spl_ddrc_regs_val.dramtmg0		= 0x090E1109;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap0		= 0x00000016;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap1		= 0x00171717;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap5		= 0x04040404;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap6		= 0x0F040404;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_rd_con0	= 0x0A0A0A0A;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_wr_con0	= 0x02020202;
+		break;
+	case SZ_2G:
+		cl_som_imx7_spl_ddrc_regs_val.mstr		= 0x01040001;
+		cl_som_imx7_spl_ddrc_regs_val.rfshtmg		= 0x0040005E;
+		cl_som_imx7_spl_ddrc_regs_val.dramtmg0		= 0x090E110A;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap0		= 0x00000018;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap1		= 0x00181818;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap5		= 0x04040404;
+		cl_som_imx7_spl_ddrc_regs_val.addrmap6		= 0x04040404;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_rd_con0	= 0x0A0A0A0A;
+		cl_som_imx7_spl_ddr_phy_regs_val.offset_wr_con0	= 0x04040404;
+		break;
+	}
+
+	return mx7_dram_cfg(&cl_som_imx7_spl_ddrc_regs_val,
+			    &cl_som_imx7_spl_ddrc_mp_val,
+			    &cl_som_imx7_spl_ddr_phy_regs_val);
+}
+
+#define CL_SOM_IMX7_WD_RESET_VAL 0x1C /* Watchdog reset value */
+
+static void cl_som_imx7_spl_dram_cfg(void)
+{
+	ulong ram_size_test, ram_size = 0;
+	struct wdog_regs *wdog = (struct wdog_regs *)WDOG1_BASE_ADDR;
+	int init_failure;
+
+	for (ram_size = SZ_2G; ram_size >= SZ_256M; ram_size >>= 1) {
+		init_failure = cl_som_imx7_spl_dram_cfg_size(ram_size);
+		if (init_failure)
+			break;
+		ram_size_test = get_ram_size((long int *)PHYS_SDRAM, ram_size);
+		if (ram_size_test == ram_size)
+			break;
+	}
+
+	/* Reset the board in case of DRAM initialization failure */
+	if (init_failure || (ram_size < SZ_256M)) {
+		puts("DRAM detection failed!!! Resetting ...\n");
+		cl_som_imx7_wdog_pads_set();
+		clrsetbits_le16(&wdog->wcr, 0, CL_SOM_IMX7_WD_RESET_VAL);
+	}
+}
+
+#ifdef CONFIG_SPL_SPI_SUPPORT
+
+static void cl_som_imx7_spl_spi_init(void)
+{
+	cl_som_imx7_espi1_pads_set();
+}
+#else /* !CONFIG_SPL_SPI_SUPPORT */
+static void cl_som_imx7_spl_spi_init(void) {}
+#endif /* CONFIG_SPL_SPI_SUPPORT */
+
+void board_init_f(ulong dummy)
+{
+	imx_iomux_v3_setup_multiple_pads(led_pads, 1);
+	/* setup AIPS and disable watchdog */
+	arch_cpu_init();
+	/* setup GP timer */
+	timer_init();
+	cl_som_imx7_spl_spi_init();
+	cl_som_imx7_uart1_pads_set();
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+	/* DRAM detection  */
+	cl_som_imx7_spl_dram_cfg();
+}
+
+void spl_board_init(void)
+{
+	u32 boot_device = spl_boot_device();
+
+	if (boot_device == BOOT_DEVICE_SPI)
+		puts("Booting from SPI flash\n");
+	else if (boot_device == BOOT_DEVICE_MMC1)
+		puts("Booting from SD card\n");
+	else
+		puts("Unknown boot device\n");
+}
+
+void board_boot_order(u32 *spl_boot_list)
+{
+	spl_boot_list[0] = spl_boot_device();
+	switch (spl_boot_list[0]) {
+	case BOOT_DEVICE_SPI:
+		spl_boot_list[1] = BOOT_DEVICE_MMC1;
+		break;
+	case BOOT_DEVICE_MMC1:
+		spl_boot_list[1] = BOOT_DEVICE_SPI;
+		break;
+	}
+}
diff --git a/board/compulab/cm_fx6/cm_fx6.c b/board/compulab/cm_fx6/cm_fx6.c
index 80b5dc9..43a2b43 100644
--- a/board/compulab/cm_fx6/cm_fx6.c
+++ b/board/compulab/cm_fx6/cm_fx6.c
@@ -19,6 +19,7 @@
 #include <fdt_support.h>
 #include <sata.h>
 #include <splash.h>
+#include <eeprom_layout.h>
 #include <asm/arch/crm_regs.h>
 #include <asm/arch/sys_proto.h>
 #include <asm/arch/iomux.h>
diff --git a/board/compulab/cm_t335/cm_t335.c b/board/compulab/cm_t335/cm_t335.c
index c4506b9..05588f7 100644
--- a/board/compulab/cm_t335/cm_t335.c
+++ b/board/compulab/cm_t335/cm_t335.c
@@ -12,6 +12,7 @@
 #include <errno.h>
 #include <miiphy.h>
 #include <cpsw.h>
+#include <eeprom_layout.h>
 
 #include <asm/arch/sys_proto.h>
 #include <asm/arch/hardware_am33xx.h>
diff --git a/board/compulab/cm_t35/cm_t35.c b/board/compulab/cm_t35/cm_t35.c
index f169125..1a474e4 100644
--- a/board/compulab/cm_t35/cm_t35.c
+++ b/board/compulab/cm_t35/cm_t35.c
@@ -21,6 +21,7 @@
 #include <mmc.h>
 #include <splash.h>
 #include <twl4030.h>
+#include <eeprom_layout.h>
 #include <linux/compiler.h>
 
 #include <asm/io.h>
diff --git a/board/compulab/cm_t3517/cm_t3517.c b/board/compulab/cm_t3517/cm_t3517.c
index 38eb641..042e6fc 100644
--- a/board/compulab/cm_t3517/cm_t3517.c
+++ b/board/compulab/cm_t3517/cm_t3517.c
@@ -12,6 +12,7 @@
 #include <netdev.h>
 #include <usb.h>
 #include <mmc.h>
+#include <eeprom_layout.h>
 #include <linux/compiler.h>
 #include <linux/usb/musb.h>
 
diff --git a/board/compulab/cm_t54/cm_t54.c b/board/compulab/cm_t54/cm_t54.c
index 6437718..40a25ac 100644
--- a/board/compulab/cm_t54/cm_t54.c
+++ b/board/compulab/cm_t54/cm_t54.c
@@ -14,6 +14,7 @@
 #include <mmc.h>
 #include <palmas.h>
 #include <spl.h>
+#include <eeprom_layout.h>
 
 #include <asm/gpio.h>
 #include <asm/arch/sys_proto.h>
diff --git a/board/compulab/common/common.c b/board/compulab/common/common.c
index bf2ac7b..9a5b2bd 100644
--- a/board/compulab/common/common.c
+++ b/board/compulab/common/common.c
@@ -10,7 +10,7 @@
 #include <asm/bootm.h>
 #include <asm/gpio.h>
 #include <asm/setup.h>
-
+#include <eeprom_layout.h>
 #include "common.h"
 #include "eeprom.h"
 
@@ -58,3 +58,205 @@ void cl_usb_hub_deinit(int gpio)
 	gpio_free(gpio);
 }
 #endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+#include <fdt_support.h>
+#include <malloc.h>
+
+/* FDT nodes list */
+static struct list_head fdt_nodes;
+
+char *fdt_node_action_name[] = {
+	"NODE_ENABLE",
+	"NODE_DISABLE",
+	"NODE_DELETE",
+	"NODE_PROP_SET",
+	"NODE_PROP_DELETE",
+};
+
+static inline void fdt_node_list_create(void)
+{
+	INIT_LIST_HEAD(&fdt_nodes);
+}
+
+static struct list_head *fdt_node_list_get(void)
+{
+	static int initialized;
+
+	if (!initialized) {
+		fdt_node_list_create();
+		initialized = 1;
+	}
+
+	return &fdt_nodes;
+}
+
+static inline void fdt_node_prepare(struct fdt_node *node, const char *name,
+				    struct fdt_node_prop *prop,
+				    enum fdt_node_action action)
+{
+	memset(node, 0, sizeof(struct fdt_node));
+	node->name = name;
+	node->acton = action;
+	node->prop = prop;
+	INIT_LIST_HEAD(&node->list);
+}
+
+static void fdt_node_insert(struct fdt_node *node)
+{
+	struct list_head *fdt_node_list = fdt_node_list_get();
+
+	list_add_tail(&node->list, fdt_node_list);
+}
+
+static int fdt_node_add(const char *name, enum fdt_node_action action)
+{
+	struct fdt_node *node = NULL;
+
+	node = (struct fdt_node *)malloc(sizeof(struct fdt_node));
+	if (!node)
+		return -ENOMEM;
+
+	fdt_node_prepare(node, name, NULL, action);
+
+	fdt_node_insert(node);
+
+	return 0;
+}
+
+int fdt_node_enable(const char *name)
+{
+	return fdt_node_add(name, FDT_NODE_ENABLE);
+}
+
+int fdt_node_disable(const char *name)
+{
+	return fdt_node_add(name, FDT_NODE_DISABLE);
+}
+
+int fdt_node_delete(const char *name)
+{
+	return fdt_node_add(name, FDT_NODE_DELETE);
+}
+
+static int fdt_prop_add(const char *node, enum fdt_node_action action,
+			const char *name, void *val, int len,
+			int create)
+{
+	struct fdt_node *new = NULL;
+	struct fdt_node_prop *prop = NULL;
+
+	prop = (struct fdt_node_prop *)malloc(sizeof(struct fdt_node_prop)
+					      + len);
+	if (!prop)
+		return -ENOMEM;
+
+	memset(prop, 0, sizeof(struct fdt_node_prop));
+	prop->name = name;
+	if (action == FDT_NODE_PROP_SET) {
+		if (val)
+			memcpy(prop->val, val, len);
+		prop->len = len;
+		prop->create = create;
+	}
+
+	/* Prepare and populate node struct, insert to the list */
+	new = (struct fdt_node *)malloc(sizeof(struct fdt_node));
+	if (!new)
+		return -ENOMEM;
+
+	fdt_node_prepare(new, node, prop, action);
+
+	fdt_node_insert(new);
+
+	return 0;
+}
+
+int fdt_prop_set(const char *node, const char *name,
+		 void *val, int len, int create)
+{
+	return fdt_prop_add(node, FDT_NODE_PROP_SET, name,
+			    val, len, create);
+}
+
+int fdt_prop_del(const char *node, const char *name)
+{
+	return fdt_prop_add(node, FDT_NODE_PROP_DELETE, name,
+			    NULL, 0, 0);
+}
+
+int __weak fdt_board_adjust(void)
+{
+	return 0;
+}
+
+int __weak ft_board_setup(void *blob, bd_t *bd)
+{
+	struct list_head *fdt_nodes_list;
+	struct list_head *entry, *tmp;
+	struct fdt_node *node;
+	struct fdt_node_prop *prop;
+	int nodeoffset;
+
+	/* Resize FDT to be on the safe side */
+	fdt_shrink_to_minimum(blob, 0);
+
+	/* Call board specific routine to populate the node list */
+	fdt_board_adjust();
+
+	/* Get node list */
+	fdt_nodes_list = fdt_node_list_get();
+
+	/* For each node check action to be done and apply required changes */
+	list_for_each_safe(entry, tmp, fdt_nodes_list) {
+		/* Get list entry */
+		node = list_entry(entry, struct fdt_node, list);
+		prop = node->prop;
+		debug("%s: get node: name %s, action %s\n",
+		      __func__, node->name, fdt_node_action_name[node->acton]);
+		if (node->acton >= FDT_NODE_PROP_SET) {
+			int i;
+			debug("%s: node prop name %s\n",
+			      __func__, node->prop->name);
+			debug("%s: prop val", __func__);
+			for (i = 0; i < node->prop->len; i++)
+				debug(" %02x", ((char *)(node->prop->val))[i]);
+			debug("\n");
+		}
+
+		switch (node->acton) {
+		case FDT_NODE_ENABLE:
+			fdt_status_okay_by_alias(blob, node->name);
+			break;
+		case FDT_NODE_DISABLE:
+			fdt_status_disabled_by_alias(blob, node->name);
+			break;
+		case FDT_NODE_DELETE:
+			fdt_del_node_and_alias(blob, node->name);
+			break;
+		case FDT_NODE_PROP_SET:
+			fdt_find_and_setprop(blob, node->name, prop->name,
+					     prop->val, prop->len,
+					     prop->create);
+			break;
+		case FDT_NODE_PROP_DELETE:
+			nodeoffset = fdt_path_offset(blob, node->name);
+			fdt_delprop(blob, nodeoffset, prop->name);
+			break;
+		default:
+			debug("%s: Error: unsupported node action\n",
+			      __func__);
+		}
+
+		/* Delete list entry */
+		list_del(entry);
+		/* Free memory allocated */
+		if (prop)
+			free(prop);
+
+		free(node);
+	}
+
+	return 0;
+}
+#endif
diff --git a/board/compulab/common/common.h b/board/compulab/common/common.h
index 759ec31..329b75b 100644
--- a/board/compulab/common/common.h
+++ b/board/compulab/common/common.h
@@ -35,4 +35,36 @@ static inline int cl_omap3_smc911x_init(int id, int cs, u32 base_addr,
 }
 #endif /* CONFIG_SMC911X */
 
+#ifdef CONFIG_OF_BOARD_SETUP
+enum fdt_node_action {
+	FDT_NODE_ENABLE,
+	FDT_NODE_DISABLE,
+	FDT_NODE_DELETE,
+	FDT_NODE_PROP_SET,
+	FDT_NODE_PROP_DELETE,
+};
+
+struct fdt_node_prop {
+	const char *name;
+	int len;
+	int create;
+	char val[0];
+};
+
+struct fdt_node {
+	struct list_head list;
+	const char *name;
+	struct fdt_node_prop *prop;
+	enum fdt_node_action acton;
+};
+
+int fdt_board_adjust(void);
+int fdt_node_enable(const char *name);
+int fdt_node_disable(const char *name);
+int fdt_node_delete(const char *name);
+int fdt_prop_set(const char *node, const char *name,
+		 void *val, int len, int create);
+int fdt_prop_del(const char *node, const char *name);
+#endif
+
 #endif /* _CL_COMMON_ */
diff --git a/board/compulab/common/eeprom.c b/board/compulab/common/eeprom.c
index bb4c9e9..ed6d3d0 100644
--- a/board/compulab/common/eeprom.c
+++ b/board/compulab/common/eeprom.c
@@ -187,6 +187,42 @@ int cl_eeprom_get_product_name(uchar *buf, uint eeprom_bus)
 }
 
 #ifdef CONFIG_CMD_EEPROM_LAYOUT
+
+/*
+ * Routine: cl_eeprom_layout_setup
+ * Description:
+ * - Read EEPROM content.
+ * - Setup layout struct with the layout data and metadata.
+ *
+ * @layout:    A pointer to an existing struct layout.
+ * @eeprom_buf:        A buffer initialized with the eeprom data.
+ * @layout version: The version number of the layout.
+ * @eeprom_bus: EEPROM I2C bus ID.
+ * @eeprom_addr: EEPROM I2C address.
+ *
+ * @return: 0 on success, < 0 on failure
+ */
+int cl_eeprom_layout_setup(struct eeprom_layout *layout, uchar *eeprom_buf,
+                           int layout_version, uint eeprom_bus,
+			   uint8_t eeprom_addr)
+{
+	int ret;
+
+	ret = i2c_set_bus_num(eeprom_bus);
+	if (ret < 0)
+		return ret;
+
+	ret = i2c_read(eeprom_addr, 0, CONFIG_SYS_I2C_EEPROM_ADDR_LEN,
+		       eeprom_buf, CONFIG_SYS_EEPROM_SIZE);
+	if (ret < 0)
+		return ret;
+
+	eeprom_layout_setup(layout, eeprom_buf, CONFIG_SYS_EEPROM_SIZE,
+			    layout_version);
+
+	return 0;
+}
+
 /**
  * eeprom_field_print_bin_ver() - print a "version field" which contains binary
  *				  data
@@ -199,17 +235,18 @@ int cl_eeprom_get_product_name(uchar *buf, uint eeprom_bus)
  *      Field Name      123.45
  *
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_bin_ver(const struct eeprom_field *field)
+void eeprom_field_print_bin_ver(const struct eeprom_field *field, uchar *fbuf)
 {
-	if ((field->buf[0] == 0xff) && (field->buf[1] == 0xff)) {
-		field->buf[0] = 0;
-		field->buf[1] = 0;
+	if ((fbuf[0] == 0xff) && (fbuf[1] == 0xff)) {
+		fbuf[0] = 0;
+		fbuf[1] = 0;
 	}
 
 	printf(PRINT_FIELD_SEGMENT, field->name);
-	int major = (field->buf[1] << 8 | field->buf[0]) / 100;
-	int minor = (field->buf[1] << 8 | field->buf[0]) - major * 100;
+	int major = (fbuf[1] << 8 | fbuf[0]) / 100;
+	int minor = (fbuf[1] << 8 | fbuf[0]) - major * 100;
 	printf("%d.%02d\n", major, minor);
 }
 
@@ -225,11 +262,13 @@ void eeprom_field_print_bin_ver(const struct eeprom_field *field)
  * field if there's any deviation from it. It also protects from overflow.
  *
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	a version string
  *
  * Returns 0 on success, -1 on failure.
  */
-int eeprom_field_update_bin_ver(struct eeprom_field *field, char *value)
+int eeprom_field_update_bin_ver(struct eeprom_field *field, uchar *fbuf,
+				char *value)
 {
 	char *endptr;
 	char *tok = strtok(value, ".");
@@ -252,8 +291,8 @@ int eeprom_field_update_bin_ver(struct eeprom_field *field, char *value)
 	if (num >> 16)
 		return -1;
 
-	field->buf[0] = (unsigned char)num;
-	field->buf[1] = num >> 8;
+	fbuf[0] = (unsigned char)num;
+	fbuf[1] = num >> 8;
 
 	return 0;
 }
@@ -270,17 +309,18 @@ char *months[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
  *      Field Name      56/BAD/9999
  *
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_date(const struct eeprom_field *field)
+void eeprom_field_print_date(const struct eeprom_field *field, uchar *fbuf)
 {
 	printf(PRINT_FIELD_SEGMENT, field->name);
-	printf("%02d/", field->buf[0]);
-	if (field->buf[1] >= 1 && field->buf[1] <= 12)
-		printf("%s", months[field->buf[1] - 1]);
+	printf("%02d/", fbuf[0]);
+	if (fbuf[1] >= 1 && fbuf[1] <= 12)
+		printf("%s", months[fbuf[1] - 1]);
 	else
 		printf("BAD");
 
-	printf("/%d\n", field->buf[3] << 8 | field->buf[2]);
+	printf("/%d\n", fbuf[3] << 8 | fbuf[2]);
 }
 
 static int validate_date(unsigned char day, unsigned char month,
@@ -338,11 +378,13 @@ static int validate_date(unsigned char day, unsigned char month,
  * year value, and checks the validity of the date.
  *
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	a date string
  *
  * Returns 0 on success, -1 on failure.
  */
-int eeprom_field_update_date(struct eeprom_field *field, char *value)
+int eeprom_field_update_date(struct eeprom_field *field, uchar *fbuf,
+			     char *value)
 {
 	char *endptr;
 	char *tok1 = strtok(value, "/");
@@ -381,10 +423,10 @@ int eeprom_field_update_date(struct eeprom_field *field, char *value)
 		return -1;
 	}
 
-	field->buf[0] = day;
-	field->buf[1] = month;
-	field->buf[2] = (unsigned char)year;
-	field->buf[3] = (unsigned char)(year >> 8);
+	fbuf[0] = day;
+	fbuf[1] = month;
+	fbuf[2] = (unsigned char)year;
+	fbuf[3] = (unsigned char)(year >> 8);
 
 	return 0;
 }
@@ -393,19 +435,28 @@ int eeprom_field_update_date(struct eeprom_field *field, char *value)
 #define	LAYOUT_VERSION_VER1 2
 #define	LAYOUT_VERSION_VER2 3
 #define	LAYOUT_VERSION_VER3 4
+#define	LAYOUT_VERSION_VER4 5
 
 extern struct eeprom_field layout_unknown[1];
 
-#define DEFINE_PRINT_UPDATE(x) eeprom_field_print_##x, eeprom_field_update_##x
+#define DEFINE_FIELD_FUNC(x) eeprom_field_print_##x, eeprom_field_update_##x, \
+			     eeprom_field_read_bin
+
+#define FIELD_FUNC_RES_LAST eeprom_field_print_reserved, \
+			    eeprom_field_update_ascii,   \
+			    eeprom_field_read_bin
+
+#define FIELD_FUNC_SERIAL eeprom_field_print_bin_rev,  \
+			  eeprom_field_update_bin_rev, \
+			  eeprom_field_read_rev
 
 #ifdef CONFIG_CM_T3X
 struct eeprom_field layout_legacy[5] = {
-	{ "MAC address",          6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "Board Revision",       2, NULL, DEFINE_PRINT_UPDATE(bin) },
-	{ "Serial Number",        8, NULL, DEFINE_PRINT_UPDATE(bin) },
-	{ "Board Configuration", 64, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ RESERVED_FIELDS,      176, NULL, eeprom_field_print_reserved,
-					   eeprom_field_update_ascii },
+	{ "MAC address",          6, DEFINE_FIELD_FUNC(mac) },
+	{ "Board Revision",       2, DEFINE_FIELD_FUNC(bin) },
+	{ "Serial Number",        8, DEFINE_FIELD_FUNC(bin) },
+	{ "Board Configuration", 64, DEFINE_FIELD_FUNC(ascii) },
+	{ RESERVED_FIELDS,      176, FIELD_FUNC_RES_LAST }
 };
 #else
 #define layout_legacy layout_unknown
@@ -413,61 +464,82 @@ struct eeprom_field layout_legacy[5] = {
 
 #if defined(CONFIG_CM_T3X) || defined(CONFIG_CM_T3517)
 struct eeprom_field layout_v1[12] = {
-	{ "Major Revision",      2, NULL, DEFINE_PRINT_UPDATE(bin_ver) },
-	{ "Minor Revision",      2, NULL, DEFINE_PRINT_UPDATE(bin_ver) },
-	{ "1st MAC Address",     6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "2nd MAC Address",     6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "Production Date",     4, NULL, DEFINE_PRINT_UPDATE(date) },
-	{ "Serial Number",      12, NULL, DEFINE_PRINT_UPDATE(bin_rev) },
-	{ RESERVED_FIELDS,      96, NULL, DEFINE_PRINT_UPDATE(reserved) },
-	{ "Product Name",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #1", 16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #2", 16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #3", 16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ RESERVED_FIELDS,      64, NULL, eeprom_field_print_reserved,
-					  eeprom_field_update_ascii },
+	{ "Major Revision",      2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "Minor Revision",      2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "1st MAC Address",     6, DEFINE_FIELD_FUNC(mac) },
+	{ "2nd MAC Address",     6, DEFINE_FIELD_FUNC(mac) },
+	{ "Production Date",     4, DEFINE_FIELD_FUNC(date) },
+	{ "Serial Number",      12, FIELD_FUNC_SERIAL },
+	{ RESERVED_FIELDS,      96, DEFINE_FIELD_FUNC(reserved) },
+	{ "Product Name",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #1", 16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #2", 16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #3", 16, DEFINE_FIELD_FUNC(ascii) },
+	{ RESERVED_FIELDS,      64, FIELD_FUNC_RES_LAST }
 };
 #else
 #define layout_v1 layout_unknown
 #endif
 
 struct eeprom_field layout_v2[15] = {
-	{ "Major Revision",            2, NULL, DEFINE_PRINT_UPDATE(bin_ver) },
-	{ "Minor Revision",            2, NULL, DEFINE_PRINT_UPDATE(bin_ver) },
-	{ "1st MAC Address",           6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "2nd MAC Address",           6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "Production Date",           4, NULL, DEFINE_PRINT_UPDATE(date) },
-	{ "Serial Number",            12, NULL, DEFINE_PRINT_UPDATE(bin_rev) },
-	{ "3rd MAC Address (WIFI)",    6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "4th MAC Address (Bluetooth)", 6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "Layout Version",            1, NULL, DEFINE_PRINT_UPDATE(bin) },
-	{ RESERVED_FIELDS,            83, NULL, DEFINE_PRINT_UPDATE(reserved) },
-	{ "Product Name",             16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #1",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #2",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #3",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ RESERVED_FIELDS,            64, NULL, eeprom_field_print_reserved,
-						eeprom_field_update_ascii },
+	{ "Major Revision",            2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "Minor Revision",            2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "1st MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "2nd MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "Production Date",           4, DEFINE_FIELD_FUNC(date) },
+	{ "Serial Number",            12, FIELD_FUNC_SERIAL },
+	{ "3rd MAC Address (WIFI)",    6, DEFINE_FIELD_FUNC(mac) },
+	{ "4th MAC Address (Bluetooth)", 6, DEFINE_FIELD_FUNC(mac) },
+	{ "Layout Version",            1, DEFINE_FIELD_FUNC(bin) },
+	{ RESERVED_FIELDS,            83, DEFINE_FIELD_FUNC(reserved) },
+	{ "Product Name",             16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #1",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #2",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #3",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ RESERVED_FIELDS,            64, FIELD_FUNC_RES_LAST },
 };
 
 struct eeprom_field layout_v3[16] = {
-	{ "Major Revision",            2, NULL, DEFINE_PRINT_UPDATE(bin_ver) },
-	{ "Minor Revision",            2, NULL, DEFINE_PRINT_UPDATE(bin_ver) },
-	{ "1st MAC Address",           6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "2nd MAC Address",           6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "Production Date",           4, NULL, DEFINE_PRINT_UPDATE(date) },
-	{ "Serial Number",            12, NULL, DEFINE_PRINT_UPDATE(bin_rev) },
-	{ "3rd MAC Address (WIFI)",    6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "4th MAC Address (Bluetooth)", 6, NULL, DEFINE_PRINT_UPDATE(mac) },
-	{ "Layout Version",            1, NULL, DEFINE_PRINT_UPDATE(bin) },
-	{ "CompuLab EEPROM ID",        3, NULL, DEFINE_PRINT_UPDATE(bin) },
-	{ RESERVED_FIELDS,            80, NULL, DEFINE_PRINT_UPDATE(reserved) },
-	{ "Product Name",             16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #1",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #2",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ "Product Options #3",       16, NULL, DEFINE_PRINT_UPDATE(ascii) },
-	{ RESERVED_FIELDS,            64, NULL, eeprom_field_print_reserved,
-						eeprom_field_update_ascii },
+	{ "Major Revision",            2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "Minor Revision",            2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "1st MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "2nd MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "Production Date",           4, DEFINE_FIELD_FUNC(date) },
+	{ "Serial Number",            12, FIELD_FUNC_SERIAL },
+	{ "3rd MAC Address (WIFI)",    6, DEFINE_FIELD_FUNC(mac) },
+	{ "4th MAC Address (Bluetooth)", 6, DEFINE_FIELD_FUNC(mac) },
+	{ "Layout Version",            1, DEFINE_FIELD_FUNC(bin) },
+	{ "CompuLab EEPROM ID",        3, DEFINE_FIELD_FUNC(bin) },
+	{ RESERVED_FIELDS,            80, DEFINE_FIELD_FUNC(reserved) },
+	{ "Product Name",             16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #1",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #2",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #3",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ RESERVED_FIELDS,            64, FIELD_FUNC_RES_LAST },
+};
+
+struct eeprom_field layout_v4[21] = {
+	{ "Major Revision",            2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "Minor Revision",            2, DEFINE_FIELD_FUNC(bin_ver) },
+	{ "1st MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "2nd MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "Production Date",           4, DEFINE_FIELD_FUNC(date) },
+	{ "Serial Number",            12, FIELD_FUNC_SERIAL },
+	{ "3rd MAC Address (WIFI)",    6, DEFINE_FIELD_FUNC(mac) },
+	{ "4th MAC Address (Bluetooth)", 6, DEFINE_FIELD_FUNC(mac) },
+	{ "Layout Version",            1, DEFINE_FIELD_FUNC(bin) },
+	{ "CompuLab EEPROM ID",        3, DEFINE_FIELD_FUNC(bin) },
+	{ "5th MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ "6th MAC Address",           6, DEFINE_FIELD_FUNC(mac) },
+	{ RESERVED_FIELDS,             4, DEFINE_FIELD_FUNC(reserved) },
+	{ RESERVED_FIELDS,            64, DEFINE_FIELD_FUNC(reserved) },
+	{ "Product Name",             16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #1",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #2",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #3",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #4",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ "Product Options #5",       16, DEFINE_FIELD_FUNC(ascii) },
+	{ RESERVED_FIELDS,            32, DEFINE_FIELD_FUNC(reserved) },
 };
 
 void eeprom_layout_assign(struct eeprom_layout *layout, int layout_version)
@@ -489,6 +561,10 @@ void eeprom_layout_assign(struct eeprom_layout *layout, int layout_version)
 		layout->fields = layout_v3;
 		layout->num_of_fields = ARRAY_SIZE(layout_v3);
 		break;
+	case LAYOUT_VERSION_VER4:
+		layout->fields = layout_v4;
+		layout->num_of_fields = ARRAY_SIZE(layout_v4);
+		break;
 	default:
 		__eeprom_layout_assign(layout, layout_version);
 	}
@@ -504,6 +580,8 @@ int eeprom_parse_layout_version(char *str)
 		return LAYOUT_VERSION_VER2;
 	else if (!strcmp(str, "v3"))
 		return LAYOUT_VERSION_VER3;
+	else if (!strcmp(str, "v4"))
+		return LAYOUT_VERSION_VER4;
 	else
 		return LAYOUT_VERSION_UNRECOGNIZED;
 }
@@ -518,6 +596,8 @@ int eeprom_layout_detect(unsigned char *data)
 		return LAYOUT_VERSION_VER2;
 	case 3:
 		return LAYOUT_VERSION_VER3;
+	case 4 ... 0x1f:
+		return LAYOUT_VERSION_VER4;
 	}
 
 	if (data[EEPROM_LAYOUT_VER_OFFSET] >= 0x20)
diff --git a/board/compulab/common/eeprom.h b/board/compulab/common/eeprom.h
index c0b4739..79f1a5d 100644
--- a/board/compulab/common/eeprom.h
+++ b/board/compulab/common/eeprom.h
@@ -12,6 +12,11 @@
 #include <errno.h>
 
 #ifdef CONFIG_SYS_I2C
+#ifdef CONFIG_CMD_EEPROM_LAYOUT
+int cl_eeprom_layout_setup(struct eeprom_layout *layout, uchar *eeprom_buf,
+			   int layout_version, uint eeprom_bus,
+			   uint8_t eeprom_addr);
+#endif /* CONFIG_CMD_EEPROM_LAYOUT */
 int cl_eeprom_read_mac_addr(uchar *buf, uint eeprom_bus);
 u32 cl_eeprom_get_board_rev(uint eeprom_bus);
 int cl_eeprom_get_product_name(uchar *buf, uint eeprom_bus);
diff --git a/board/corscience/tricorder/tricorder-eeprom.c b/board/corscience/tricorder/tricorder-eeprom.c
index aeacd6a..61d5bea 100644
--- a/board/corscience/tricorder/tricorder-eeprom.c
+++ b/board/corscience/tricorder/tricorder-eeprom.c
@@ -168,12 +168,12 @@ int tricorder_eeprom_write(unsigned devaddr, const char *name,
 	eeprom_init(CONFIG_SYS_EEPROM_BUS_NUM);
 
 	ret = eeprom_write(devaddr, 0, (unsigned char *)&eeprom,
-			TRICORDER_EEPROM_SIZE);
+			   TRICORDER_EEPROM_SIZE, 1);
 	if (ret)
 		printf("Tricorder: Could not write EEPROM content!\n");
 
 	ret = eeprom_read(devaddr, 0, (unsigned char *)&eeprom_verify,
-			TRICORDER_EEPROM_SIZE);
+			  TRICORDER_EEPROM_SIZE, 1);
 	if (ret)
 		printf("Tricorder: Could not read EEPROM content!\n");
 
diff --git a/board/freescale/mpc8323erdb/mpc8323erdb.c b/board/freescale/mpc8323erdb/mpc8323erdb.c
index f30a151..bbada0a 100644
--- a/board/freescale/mpc8323erdb/mpc8323erdb.c
+++ b/board/freescale/mpc8323erdb/mpc8323erdb.c
@@ -197,7 +197,7 @@ int mac_read_from_eeprom(void)
 	unsigned char enetvar[32];
 
 	/* Read MAC addresses from EEPROM */
-	if (eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_MAC_OFFSET, buf, 28)) {
+	if (eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_SYS_I2C_MAC_OFFSET, buf, 28, 1)) {
 		printf("\nEEPROM @ 0x%02x read FAILED!!!\n",
 		       CONFIG_SYS_I2C_EEPROM_ADDR);
 	} else {
diff --git a/board/freescale/mx28evk/mx28evk.c b/board/freescale/mx28evk/mx28evk.c
index 5005fe2..577acfc 100644
--- a/board/freescale/mx28evk/mx28evk.c
+++ b/board/freescale/mx28evk/mx28evk.c
@@ -118,13 +118,15 @@ int board_eth_init(bd_t *bis)
 	udelay(200);
 	gpio_set_value(MX28_PAD_ENET0_RX_CLK__GPIO_4_13, 1);
 
-	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE);
+	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE,
+				      MXS_ENET0_BASE);
 	if (ret) {
 		puts("FEC MXS: Unable to init FEC0\n");
 		return ret;
 	}
 
-	ret = fecmxc_initialize_multi(bis, 1, 3, MXS_ENET1_BASE);
+	ret = fecmxc_initialize_multi(bis, 1, 3, MXS_ENET1_BASE,
+				      MXS_ENET1_BASE);
 	if (ret) {
 		puts("FEC MXS: Unable to init FEC1\n");
 		return ret;
diff --git a/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c b/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
index e7ab810..1c6cb3b 100644
--- a/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
+++ b/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
@@ -101,7 +101,7 @@ int board_eth_init(bd_t *bis)
 	setup_fec();
 
 	ret = fecmxc_initialize_multi(bis, 1,
-		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE, IMX_FEC_BASE);
 	if (ret)
 		printf("FEC%d MXC: %s:failed\n", 1, __func__);
 
diff --git a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
index a5746fe..ce1eb70 100644
--- a/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
+++ b/board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c
@@ -518,7 +518,8 @@ int board_eth_init(bd_t *bis)
 	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
 
 	return fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
-				       CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+				       CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE,
+				       IMX_FEC_BASE);
 }
 
 static int setup_fec(int fec_id)
diff --git a/board/freescale/mx7dsabresd/mx7dsabresd.c b/board/freescale/mx7dsabresd/mx7dsabresd.c
index ecea5a5..304cc5d 100644
--- a/board/freescale/mx7dsabresd/mx7dsabresd.c
+++ b/board/freescale/mx7dsabresd/mx7dsabresd.c
@@ -243,7 +243,7 @@ int board_eth_init(bd_t *bis)
 	setup_iomux_fec();
 
 	ret = fecmxc_initialize_multi(bis, 0,
-		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE, IMX_FEC_BASE);
 	if (ret)
 		printf("FEC1 MXC: %s:failed\n", __func__);
 
diff --git a/board/kosagi/novena/novena.c b/board/kosagi/novena/novena.c
index f6972c2..c8e62b9 100644
--- a/board/kosagi/novena/novena.c
+++ b/board/kosagi/novena/novena.c
@@ -251,7 +251,7 @@ int misc_init_r(void)
 	}
 
 	/* EEPROM is at address 0x56. */
-	ret = eeprom_read(0x56, 0, datap, sizeof(data));
+	ret = eeprom_read(0x56, 0, datap, sizeof(data), 1);
 	if (ret) {
 		puts("Cannot read I2C EEPROM.\n");
 		return 0;
diff --git a/board/ppcag/bg0900/bg0900.c b/board/ppcag/bg0900/bg0900.c
index 06612fa..305fa5e 100644
--- a/board/ppcag/bg0900/bg0900.c
+++ b/board/ppcag/bg0900/bg0900.c
@@ -68,7 +68,8 @@ int board_eth_init(bd_t *bis)
 	udelay(200);
 	gpio_set_value(MX28_PAD_ENET0_RX_CLK__GPIO_4_13, 1);
 
-	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE);
+	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE,
+				      MXS_ENET0_BASE);
 	if (ret) {
 		puts("FEC MXS: Unable to init FEC0\n");
 		return ret;
diff --git a/board/samtec/vining_2000/vining_2000.c b/board/samtec/vining_2000/vining_2000.c
index c92f37c..cfc9c9a 100644
--- a/board/samtec/vining_2000/vining_2000.c
+++ b/board/samtec/vining_2000/vining_2000.c
@@ -158,7 +158,7 @@ int board_eth_init(bd_t *bis)
 	mdelay(1);
 
 	ret = fecmxc_initialize_multi(bis, 0, CONFIG_FEC_MXC_PHYADDR,
-					IMX_FEC_BASE);
+				      IMX_FEC_BASE, IMX_FEC_BASE);
 	if (ret)
 		goto eth_fail;
 
diff --git a/board/samtec/vining_fpga/socfpga.c b/board/samtec/vining_fpga/socfpga.c
index f888ecb..bfe7abf 100644
--- a/board/samtec/vining_fpga/socfpga.c
+++ b/board/samtec/vining_fpga/socfpga.c
@@ -60,7 +60,7 @@ int misc_init_r(void)
 	}
 
 	/* EEPROM is at address 0x50. */
-	ret = eeprom_read(0x50, 0, data, sizeof(data));
+	ret = eeprom_read(0x50, 0, data, sizeof(data), 1);
 	if (ret) {
 		puts("Cannot read I2C EEPROM.\n");
 		return 0;
diff --git a/board/schulercontrol/sc_sps_1/sc_sps_1.c b/board/schulercontrol/sc_sps_1/sc_sps_1.c
index 7f0b591..ba9735d 100644
--- a/board/schulercontrol/sc_sps_1/sc_sps_1.c
+++ b/board/schulercontrol/sc_sps_1/sc_sps_1.c
@@ -79,13 +79,15 @@ int board_eth_init(bd_t *bis)
 		CLKCTRL_ENET_TIME_SEL_MASK,
 		CLKCTRL_ENET_TIME_SEL_RMII_CLK | CLKCTRL_ENET_CLK_OUT_EN);
 
-	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE);
+	ret = fecmxc_initialize_multi(bis, 0, 0, MXS_ENET0_BASE,
+				      MXS_ENET0_BASE);
 	if (ret) {
 		printf("FEC MXS: Unable to init FEC0\n");
 		return ret;
 	}
 
-	ret = fecmxc_initialize_multi(bis, 1, 1, MXS_ENET1_BASE);
+	ret = fecmxc_initialize_multi(bis, 1, 1, MXS_ENET1_BASE,
+				      MXS_ENET1_BASE);
 	if (ret) {
 		printf("FEC MXS: Unable to init FEC1\n");
 		return ret;
diff --git a/board/technexion/pico-imx7d/pico-imx7d.c b/board/technexion/pico-imx7d/pico-imx7d.c
index 799751d..42a3d4a 100644
--- a/board/technexion/pico-imx7d/pico-imx7d.c
+++ b/board/technexion/pico-imx7d/pico-imx7d.c
@@ -169,7 +169,7 @@ int board_eth_init(bd_t *bis)
 	setup_iomux_fec();
 
 	return fecmxc_initialize_multi(bis, 0,
-		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE, IMX_FEC_BASE);
 }
 
 static int setup_fec(void)
diff --git a/board/toradex/colibri_imx7/colibri_imx7.c b/board/toradex/colibri_imx7/colibri_imx7.c
index e54afa1..4f837d7 100644
--- a/board/toradex/colibri_imx7/colibri_imx7.c
+++ b/board/toradex/colibri_imx7/colibri_imx7.c
@@ -253,7 +253,7 @@ int board_eth_init(bd_t *bis)
 	setup_iomux_fec();
 
 	ret = fecmxc_initialize_multi(bis, 0,
-		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE, IMX_FEC_BASE);
 	if (ret)
 		printf("FEC1 MXC: %s:failed\n", __func__);
 
diff --git a/board/xilinx/zynq/board.c b/board/xilinx/zynq/board.c
index b2fbecf..8a21e4d 100644
--- a/board/xilinx/zynq/board.c
+++ b/board/xilinx/zynq/board.c
@@ -122,7 +122,7 @@ int zynq_board_read_rom_ethaddr(unsigned char *ethaddr)
     defined(CONFIG_ZYNQ_GEM_I2C_MAC_OFFSET)
 	if (eeprom_read(CONFIG_ZYNQ_GEM_EEPROM_ADDR,
 			CONFIG_ZYNQ_GEM_I2C_MAC_OFFSET,
-			ethaddr, 6))
+			ethaddr, 6, 1))
 		printf("I2C EEPROM MAC address read failed\n");
 #endif
 
diff --git a/board/xilinx/zynqmp/zynqmp.c b/board/xilinx/zynqmp/zynqmp.c
index 51a3d9f..2d6514e 100644
--- a/board/xilinx/zynqmp/zynqmp.c
+++ b/board/xilinx/zynqmp/zynqmp.c
@@ -180,7 +180,7 @@ int zynq_board_read_rom_ethaddr(unsigned char *ethaddr)
 
 	if (eeprom_read(CONFIG_ZYNQ_GEM_EEPROM_ADDR,
 			CONFIG_ZYNQ_GEM_I2C_MAC_OFFSET,
-			ethaddr, 6))
+			ethaddr, 6, 1))
 		printf("I2C EEPROM MAC address read failed\n");
 #endif
 
diff --git a/cmd/eeprom.c b/cmd/eeprom.c
index c61b396..d342048 100644
--- a/cmd/eeprom.c
+++ b/cmd/eeprom.c
@@ -126,7 +126,7 @@ static int eeprom_len(unsigned offset, unsigned end)
 }
 
 static int eeprom_rw_block(unsigned offset, uchar *addr, unsigned alen,
-			   uchar *buffer, unsigned len, bool read)
+			   uchar *buffer, unsigned len, bool read, int set_bus)
 {
 	int ret = 0;
 
@@ -139,7 +139,8 @@ static int eeprom_rw_block(unsigned offset, uchar *addr, unsigned alen,
 #else	/* I2C */
 
 #if defined(CONFIG_SYS_I2C_EEPROM_BUS)
-	i2c_set_bus_num(CONFIG_SYS_I2C_EEPROM_BUS);
+	if (set_bus)
+		i2c_set_bus_num(CONFIG_SYS_I2C_EEPROM_BUS);
 #endif
 
 	if (read)
@@ -154,7 +155,7 @@ static int eeprom_rw_block(unsigned offset, uchar *addr, unsigned alen,
 }
 
 static int eeprom_rw(unsigned dev_addr, unsigned offset, uchar *buffer,
-		     unsigned cnt, bool read)
+		     unsigned cnt, bool read, int set_bus)
 {
 	unsigned end = offset + cnt;
 	unsigned alen, len;
@@ -166,7 +167,8 @@ static int eeprom_rw(unsigned dev_addr, unsigned offset, uchar *buffer,
 
 		len = eeprom_len(offset, end);
 
-		rcode = eeprom_rw_block(offset, addr, alen, buffer, len, read);
+		rcode = eeprom_rw_block(offset, addr, alen, buffer, len, read,
+					set_bus);
 
 		buffer += len;
 		offset += len;
@@ -178,18 +180,19 @@ static int eeprom_rw(unsigned dev_addr, unsigned offset, uchar *buffer,
 	return rcode;
 }
 
-int eeprom_read(unsigned dev_addr, unsigned offset, uchar *buffer, unsigned cnt)
+int eeprom_read(unsigned dev_addr, unsigned offset, uchar *buffer, unsigned cnt,
+		int set_bus)
 {
 	/*
 	 * Read data until done or would cross a page boundary.
 	 * We must write the address again when changing pages
 	 * because the next page may be in a different device.
 	 */
-	return eeprom_rw(dev_addr, offset, buffer, cnt, 1);
+	return eeprom_rw(dev_addr, offset, buffer, cnt, 1, set_bus);
 }
 
 int eeprom_write(unsigned dev_addr, unsigned offset,
-		 uchar *buffer, unsigned cnt)
+		 uchar *buffer, unsigned cnt, int set_bus)
 {
 	int ret;
 
@@ -200,7 +203,7 @@ int eeprom_write(unsigned dev_addr, unsigned offset,
 	 * We must write the address again when changing pages
 	 * because the address counter only increments within a page.
 	 */
-	ret = eeprom_rw(dev_addr, offset, buffer, cnt, 0);
+	ret = eeprom_rw(dev_addr, offset, buffer, cnt, 0, set_bus);
 
 	eeprom_write_enable(dev_addr, 0);
 	return ret;
@@ -230,7 +233,6 @@ static int parse_i2c_bus_addr(int *i2c_bus, ulong *i2c_addr, int argc,
 {
 	int argc_no_bus = argc_no_bus_addr + 1;
 	int argc_bus_addr = argc_no_bus_addr + 2;
-
 #ifdef CONFIG_SYS_DEF_EEPROM_ADDR
 	if (argc == argc_no_bus_addr) {
 		*i2c_bus = -1;
@@ -309,21 +311,21 @@ static int eeprom_execute_command(enum eeprom_action action, int i2c_bus,
 	if (action == EEPROM_READ) {
 		printf(fmt, i2c_addr, "read", addr, off, cnt);
 
-		rcode = eeprom_read(i2c_addr, off, (uchar *)addr, cnt);
+		rcode = eeprom_read(i2c_addr, off, (uchar *)addr, cnt, 0);
 
 		puts("done\n");
 		return rcode;
 	} else if (action == EEPROM_WRITE) {
 		printf(fmt, i2c_addr, "write", addr, off, cnt);
 
-		rcode = eeprom_write(i2c_addr, off, (uchar *)addr, cnt);
+		rcode = eeprom_write(i2c_addr, off, (uchar *)addr, cnt, 0);
 
 		puts("done\n");
 		return rcode;
 	}
 
 #ifdef CONFIG_CMD_EEPROM_LAYOUT
-	rcode = eeprom_read(i2c_addr, 0, eeprom_buf, CONFIG_SYS_EEPROM_SIZE);
+	rcode = eeprom_read(i2c_addr, 0, eeprom_buf, CONFIG_SYS_EEPROM_SIZE, 0);
 	if (rcode < 0)
 		return rcode;
 
@@ -337,7 +339,7 @@ static int eeprom_execute_command(enum eeprom_action action, int i2c_bus,
 
 	layout.update(&layout, key, value);
 
-	rcode = eeprom_write(i2c_addr, 0, layout.data, CONFIG_SYS_EEPROM_SIZE);
+	rcode = eeprom_write(i2c_addr, 0, layout.data, CONFIG_SYS_EEPROM_SIZE, 0);
 #endif
 
 	return rcode;
diff --git a/common/eeprom/eeprom_field.c b/common/eeprom/eeprom_field.c
index 7f095a6..decda0b 100644
--- a/common/eeprom/eeprom_field.c
+++ b/common/eeprom/eeprom_field.c
@@ -12,7 +12,7 @@
 #include <eeprom_field.h>
 
 static void __eeprom_field_print_bin(const struct eeprom_field *field,
-				     char *delimiter, bool reverse)
+				     uchar *fbuf, char *delimiter, bool reverse)
 {
 	int i;
 	int from = reverse ? field->size - 1 : 0;
@@ -20,12 +20,12 @@ static void __eeprom_field_print_bin(const struct eeprom_field *field,
 
 	printf(PRINT_FIELD_SEGMENT, field->name);
 	for (i = from; i != to; reverse ? i-- : i++)
-		printf("%02x%s", field->buf[i], delimiter);
+		printf("%02x%s", fbuf[i], delimiter);
 
-	printf("%02x\n", field->buf[i]);
+	printf("%02x\n", fbuf[i]);
 }
 
-static int __eeprom_field_update_bin(struct eeprom_field *field,
+static int __eeprom_field_update_bin(struct eeprom_field *field, uchar *fbuf,
 				     const char *value, bool reverse)
 {
 	int len = strlen(value);
@@ -37,7 +37,7 @@ static int __eeprom_field_update_bin(struct eeprom_field *field,
 	if (len > field->size * 2)
 		return -1;
 
-	memset(field->buf, 0, field->size);
+	memset(fbuf, 0, field->size);
 
 	/* i - string iterator, j - buf iterator */
 	for (j = 0; j < field->size; j++) {
@@ -60,7 +60,7 @@ static int __eeprom_field_update_bin(struct eeprom_field *field,
 		if (*endptr != '\0' || byte < 0)
 			return -1;
 
-		field->buf[j] = byte;
+		fbuf[j] = byte;
 		i = reverse ? i - 2 : i + 2;
 	}
 
@@ -68,7 +68,8 @@ static int __eeprom_field_update_bin(struct eeprom_field *field,
 }
 
 static int __eeprom_field_update_bin_delim(struct eeprom_field *field,
-					   char *value, char *delimiter)
+					   uchar *fbuf, char *value,
+					   char *delimiter)
 {
 	int count = 0;
 	int i, val;
@@ -93,7 +94,7 @@ static int __eeprom_field_update_bin_delim(struct eeprom_field *field,
 			return -1;
 
 		/* here we assume that each tok is no more than byte long */
-		field->buf[i] = (unsigned char)val;
+		fbuf[i] = (unsigned char)val;
 		tok = strtok(NULL, delimiter);
 	}
 
@@ -109,21 +110,46 @@ static int __eeprom_field_update_bin_delim(struct eeprom_field *field,
  *      Field Name       0102030405060708090a
  *
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_bin(const struct eeprom_field *field)
+void eeprom_field_print_bin(const struct eeprom_field *field, uchar *fbuf)
 {
-	__eeprom_field_print_bin(field, "", false);
+	__eeprom_field_print_bin(field, fbuf, "", false);
 }
 
 /**
  * eeprom_field_update_bin() - Update field with new data in binary form
  *
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	a string of values (i.e. "10b234a")
  */
-int eeprom_field_update_bin(struct eeprom_field *field, char *value)
+int eeprom_field_update_bin(struct eeprom_field *field, uchar *fbuf,
+			    char *value)
 {
-	return __eeprom_field_update_bin(field, value, false);
+	return __eeprom_field_update_bin(field, fbuf, value, false);
+}
+
+/**
+ * eeprom_field_read_bin() - Read field data in binary form
+ *
+ * @field:     an initialized field
+ * @fbuf:      field buffer
+ * @buf:       read buffer
+ * @buf_size:  read buffer size
+ */
+int eeprom_field_read_bin(const struct eeprom_field *field, uchar *fbuf,
+                         uchar *buf, int buf_size)
+{
+	memset(buf, 0, buf_size);
+	if (field->size <= 0)
+		return 0;
+	if (field->size > buf_size)
+		memcpy(buf, fbuf, buf_size);
+	else
+		memcpy(buf, fbuf, field->size);
+
+	return 0;
 }
 
 /**
@@ -131,11 +157,13 @@ int eeprom_field_update_bin(struct eeprom_field *field, char *value)
  *				    binary form
  *
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	a space delimited string of byte values (i.e. "1 02 3 0x4")
  */
-int eeprom_field_update_reserved(struct eeprom_field *field, char *value)
+int eeprom_field_update_reserved(struct eeprom_field *field, uchar *fbuf,
+				 char *value)
 {
-	return __eeprom_field_update_bin_delim(field, value, " ");
+	return __eeprom_field_update_bin_delim(field, fbuf, value, " ");
 }
 
 /**
@@ -151,10 +179,11 @@ int eeprom_field_update_reserved(struct eeprom_field *field, char *value)
  *      Field Name      0a090807060504030201
  *
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_bin_rev(const struct eeprom_field *field)
+void eeprom_field_print_bin_rev(const struct eeprom_field *field, uchar *fbuf)
 {
-	__eeprom_field_print_bin(field, "", true);
+	__eeprom_field_print_bin(field, fbuf, "", true);
 }
 
 /**
@@ -166,11 +195,34 @@ void eeprom_field_print_bin_rev(const struct eeprom_field *field)
  * "3412" will be written to the field.
  *
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	a string of byte values
  */
-int eeprom_field_update_bin_rev(struct eeprom_field *field, char *value)
+int eeprom_field_update_bin_rev(struct eeprom_field *field, uchar *fbuf,
+				char *value)
+{
+	return __eeprom_field_update_bin(field, fbuf, value, true);
+}
+
+/**
+ * eeprom_field_read_rev() - Read reversed binary data
+ *
+ * @field:     an initialized field
+ * @fbuf:      field buffer
+ * @buf:       read buffer
+ * @buf_size:  read buffer size
+ */
+int eeprom_field_read_rev(const struct eeprom_field *field, uchar *fbuf,
+			  uchar *buf, int buf_size)
 {
-	return __eeprom_field_update_bin(field, value, true);
+	int i;
+
+	memset(buf, 0, buf_size);
+
+	for (i = field->size - 1; i >= 0; i--, buf++)
+		*buf = fbuf[i];
+
+	return 0;
 }
 
 /**
@@ -182,10 +234,12 @@ int eeprom_field_update_bin_rev(struct eeprom_field *field, char *value)
  *      Field Name     01:02:03:04:05:06
  *
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_mac(const struct eeprom_field *field)
+void eeprom_field_print_mac(const struct eeprom_field *field, uchar *fbuf)
+
 {
-	__eeprom_field_print_bin(field, ":", false);
+	__eeprom_field_print_bin(field, fbuf, ":", false);
 }
 
 /**
@@ -193,42 +247,47 @@ void eeprom_field_print_mac(const struct eeprom_field *field)
  *			       data
  *
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	a colon delimited string of byte values (i.e. "1:02:3:ff")
  */
-int eeprom_field_update_mac(struct eeprom_field *field, char *value)
+int eeprom_field_update_mac(struct eeprom_field *field, uchar *fbuf,
+			    char *value)
 {
-	return __eeprom_field_update_bin_delim(field, value, ":");
+	return __eeprom_field_update_bin_delim(field, fbuf, value, ":");
 }
 
 /**
  * eeprom_field_print_ascii() - print a field which contains ASCII data
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_ascii(const struct eeprom_field *field)
+void eeprom_field_print_ascii(const struct eeprom_field *field, uchar *fbuf)
 {
 	char format[8];
 
 	sprintf(format, "%%.%ds\n", field->size);
 	printf(PRINT_FIELD_SEGMENT, field->name);
-	printf(format, field->buf);
+	printf(format, fbuf);
 }
 
 /**
  * eeprom_field_update_ascii() - Update field with new data in ASCII form
  * @field:	an initialized field
+ * @fbuf:	field buffer
  * @value:	the new string data
  *
  * Returns 0 on success, -1 of failure (new string too long).
  */
-int eeprom_field_update_ascii(struct eeprom_field *field, char *value)
+int eeprom_field_update_ascii(struct eeprom_field *field, uchar *fbuf,
+			      char *value)
 {
 	if (strlen(value) >= field->size) {
 		printf("%s: new data too long\n", field->name);
 		return -1;
 	}
 
-	strncpy((char *)field->buf, value, field->size - 1);
-	field->buf[field->size - 1] = '\0';
+	strncpy((char *)fbuf, value, field->size - 1);
+	fbuf[field->size - 1] = '\0';
 
 	return 0;
 }
@@ -242,8 +301,9 @@ int eeprom_field_update_ascii(struct eeprom_field *field, char *value)
  *      Reserved fields              (64 bytes)
  *
  * @field:	an initialized field to print
+ * @fbuf:	field buffer
  */
-void eeprom_field_print_reserved(const struct eeprom_field *field)
+void eeprom_field_print_reserved(const struct eeprom_field *field, uchar *fbuf)
 {
 	printf(PRINT_FIELD_SEGMENT, "Reserved fields\t");
 	printf("(%d bytes)\n", field->size);
diff --git a/common/eeprom/eeprom_layout.c b/common/eeprom/eeprom_layout.c
index c059233..3d8b4ec 100644
--- a/common/eeprom/eeprom_layout.c
+++ b/common/eeprom/eeprom_layout.c
@@ -15,8 +15,8 @@
 #define NO_LAYOUT_FIELDS	"Unknown layout. Dumping raw data\n"
 
 struct eeprom_field layout_unknown[1] = {
-	{ NO_LAYOUT_FIELDS, 256, NULL, eeprom_field_print_bin,
-				       eeprom_field_update_bin },
+	{ NO_LAYOUT_FIELDS, 256, eeprom_field_print_bin,
+	  eeprom_field_update_bin },
 };
 
 /*
@@ -52,9 +52,10 @@ static void eeprom_layout_print(const struct eeprom_layout *layout)
 {
 	int i;
 	struct eeprom_field *fields = layout->fields;
+	uchar *fbuf = layout->data;
 
-	for (i = 0; i < layout->num_of_fields; i++)
-		fields[i].print(&fields[i]);
+	for (i = 0; i < layout->num_of_fields; fbuf += fields[i++].size)
+		fields[i].print(&fields[i], fbuf);
 }
 
 /*
@@ -70,6 +71,7 @@ static int eeprom_layout_update_field(struct eeprom_layout *layout,
 {
 	int i, err;
 	struct eeprom_field *fields = layout->fields;
+	uchar *fbuf = layout->data;
 
 	if (new_data == NULL)
 		return 0;
@@ -77,12 +79,12 @@ static int eeprom_layout_update_field(struct eeprom_layout *layout,
 	if (field_name == NULL)
 		return -1;
 
-	for (i = 0; i < layout->num_of_fields; i++) {
+	for (i = 0; i < layout->num_of_fields; fbuf += fields[i++].size) {
 		if (fields[i].name == RESERVED_FIELDS ||
 		    strcmp(fields[i].name, field_name))
 			continue;
 
-		err = fields[i].update(&fields[i], new_data);
+		err = fields[i].update(&fields[i], fbuf, new_data);
 		if (err)
 			printf("Invalid data for field %s\n", field_name);
 
@@ -95,6 +97,42 @@ static int eeprom_layout_update_field(struct eeprom_layout *layout,
 }
 
 /*
+ * eeprom_layout_read_field() - read a single field from the layout data
+ * @layout:    A pointer to an existing struct layout.
+ * @field_name:        The name of the field to update.
+ * @buf:       Read data buffer.
+ * @buf_size:  Read data buffer size.
+ *
+ * Returns: 0 on success, negative error value on failure.
+ */
+static int eeprom_layout_read_field(struct eeprom_layout *layout,
+				    char *field_name, uchar *buf, int buf_size)
+{
+       int i, err;
+       struct eeprom_field *fields = layout->fields;
+       uchar *fbuf = layout->data;
+
+       if ((field_name == NULL) || (buf == NULL) || (buf_size <= 0))
+               return -1;
+
+	for (i = 0; i < layout->num_of_fields; fbuf += fields[i++].size) {
+		if (fields[i].name == RESERVED_FIELDS ||
+		    strcmp(fields[i].name, field_name))
+			continue;
+
+		err = fields[i].read(&fields[i], fbuf, buf, buf_size);
+		if (err)
+			printf("Field %s, read error\n", field_name);
+
+		return err;
+	}
+
+	printf("No such field '%s'\n", field_name);
+
+	return -1;
+}
+
+/*
  * eeprom_layout_setup() - setup layout struct with the layout data and
  *			   metadata as dictated by layout_version
  * @layout:	A pointer to an existing struct layout.
@@ -105,8 +143,6 @@ static int eeprom_layout_update_field(struct eeprom_layout *layout,
 void eeprom_layout_setup(struct eeprom_layout *layout, unsigned char *buf,
 			 unsigned int buf_size, int layout_version)
 {
-	int i;
-
 	if (layout_version == LAYOUT_VERSION_AUTODETECT)
 		layout->layout_version = eeprom_layout_detect(buf);
 	else
@@ -114,12 +150,8 @@ void eeprom_layout_setup(struct eeprom_layout *layout, unsigned char *buf,
 
 	eeprom_layout_assign(layout, layout_version);
 	layout->data = buf;
-	for (i = 0; i < layout->num_of_fields; i++) {
-		layout->fields[i].buf = buf;
-		buf += layout->fields[i].size;
-	}
-
 	layout->data_size = buf_size;
 	layout->print = eeprom_layout_print;
 	layout->update = eeprom_layout_update_field;
+	layout->read = eeprom_layout_read_field;
 }
diff --git a/common/env_eeprom.c b/common/env_eeprom.c
index 5f63a6c..2584c88 100644
--- a/common/env_eeprom.c
+++ b/common/env_eeprom.c
@@ -36,7 +36,7 @@ static int eeprom_bus_read(unsigned dev_addr, unsigned offset,
 		i2c_set_bus_num(CONFIG_I2C_ENV_EEPROM_BUS);
 #endif
 
-	rcode = eeprom_read(dev_addr, offset, buffer, cnt);
+	rcode = eeprom_read(dev_addr, offset, buffer, cnt, 1);
 
 #if defined(CONFIG_I2C_ENV_EEPROM_BUS)
 	i2c_set_bus_num(old_bus);
@@ -56,7 +56,7 @@ static int eeprom_bus_write(unsigned dev_addr, unsigned offset,
 		i2c_set_bus_num(CONFIG_I2C_ENV_EEPROM_BUS);
 #endif
 
-	rcode = eeprom_write(dev_addr, offset, buffer, cnt);
+	rcode = eeprom_write(dev_addr, offset, buffer, cnt, 1);
 
 #if defined(CONFIG_I2C_ENV_EEPROM_BUS)
 	i2c_set_bus_num(old_bus);
diff --git a/configs/cl_som_imx7_defconfig b/configs/cl_som_imx7_defconfig
new file mode 100644
index 0000000..1ce6e0f
--- /dev/null
+++ b/configs/cl_som_imx7_defconfig
@@ -0,0 +1,69 @@
+CONFIG_ARM=y
+CONFIG_ARCH_MX7=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_TARGET_CL_SOM_IMX7=y
+CONFIG_SYS_I2C_EEPROM_BASE_BUS=1
+CONFIG_SYS_I2C_EEPROM_BASE_ADDR=0x54
+CONFIG_SPL_MMC_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_SPL_SPI_FLASH_SUPPORT=y
+CONFIG_SPL_SPI_SUPPORT=y
+CONFIG_VIDEO=y
+CONFIG_ARMV7_BOOT_SEC_DEFAULT=y
+CONFIG_IMX_RDC=y
+CONFIG_IMX_BOOTAUX=y
+CONFIG_OF_BOARD_SETUP=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=arch/arm/imx-common/spl_sd.cfg"
+CONFIG_SPI_BOOT=y
+CONFIG_BOOTDELAY=3
+# CONFIG_DISPLAY_BOARDINFO is not set
+CONFIG_SPL=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x80
+CONFIG_SPL_I2C_SUPPORT=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="CL-SOM-iMX7 # "
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_IMI is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+CONFIG_CMD_GREPENV=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_BMP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_LED_STATUS=y
+CONFIG_LED_STATUS_GPIO=y
+CONFIG_LED_STATUS0=y
+CONFIG_LED_STATUS_BIT=174
+CONFIG_LED_STATUS_STATE=2
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_ATMEL=y
+CONFIG_SPI_FLASH_EON=y
+CONFIG_SPI_FLASH_GIGADEVICE=y
+CONFIG_SPI_FLASH_MACRONIX=y
+CONFIG_SPI_FLASH_SPANSION=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SPI_FLASH_SST=y
+CONFIG_SPI_FLASH_WINBOND=y
+CONFIG_USB=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_MXC_USB_OTG_HACTIVE=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=y
+CONFIG_CI_UDC=y
+CONFIG_OF_LIBFDT=y
diff --git a/drivers/mtd/nand/mxs_nand.c b/drivers/mtd/nand/mxs_nand.c
index 9200544..1a5b5f7 100644
--- a/drivers/mtd/nand/mxs_nand.c
+++ b/drivers/mtd/nand/mxs_nand.c
@@ -7,7 +7,7 @@
  * Based on code from LTIB:
  * Freescale GPMI NFC NAND Flash Driver
  *
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2016 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Embedded Alley Solutions, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -46,6 +46,11 @@
 
 #define	MXS_NAND_BCH_TIMEOUT			10000
 
+int bbm_chunk;
+int ecc_strength;
+bool large_oob_flag;
+bool ecc_for_meta;
+
 struct mxs_nand_info {
 	int		cur_chip;
 
@@ -137,7 +142,8 @@ static void mxs_nand_return_dma_descs(struct mxs_nand_info *info)
 
 static uint32_t mxs_nand_ecc_chunk_cnt(uint32_t page_data_size)
 {
-	return page_data_size / chunk_data_size;
+	int tmp = page_data_size / chunk_data_size;
+	return ecc_for_meta ? tmp + 1 : tmp;
 }
 
 static uint32_t mxs_nand_ecc_size_in_bits(uint32_t ecc_strength)
@@ -150,10 +156,50 @@ static uint32_t mxs_nand_aux_status_offset(void)
 	return (MXS_NAND_METADATA_SIZE + 0x3) & ~0x3;
 }
 
-static inline uint32_t mxs_nand_get_ecc_strength(uint32_t page_data_size,
-						uint32_t page_oob_size)
+/*
+ * For some large oob NAND chip( the oob larger than data chunk), combined meta
+ * with chunk0 style bch layout might override the bbm with ecc data. The
+ * function checked if bbm can be in the data chunk. If it is true, chunk_num
+ * indicate the chunk number that bbm located.
+ *
+ */
+static bool mxs_nand_bbm_in_data_chunk(struct mtd_info *mtd, int gf_len,
+		int *chunk_num)
+{
+	int i, j;
+	int meta = MXS_NAND_METADATA_SIZE;
+
+	i = (mtd->writesize * 8 - meta * 8) /
+		(gf_len * ecc_strength +
+		chunk_data_size * 8);
+
+	j = (mtd->writesize * 8 - meta * 8) %
+		(gf_len * ecc_strength +
+		chunk_data_size * 8);
+
+	if (j < chunk_data_size * 8) {
+		*chunk_num = i+1;
+		return true;
+       }
+
+	return false;
+}
+
+/*
+ * the work flow about how to set the ecc layout
+ *
+ * 1. if ecc_strength_ds>max_soc_ecc, quit
+ * 2. if ecc_strength_ds>0 and ecc_stride_ds>0,
+ *         if ecc_stride_ds > oob, go to large_oob branch
+ *         else go to normal branch
+ * 3. if either ecc_stride_ds<=0 or ecc_stride_ds<=0, quit
+ *
+ */
+static int mxs_nand_get_ecc_strength(struct mtd_info *mtd)
 {
-	int ecc_strength;
+	struct nand_chip *chip = mtd_to_nand(mtd);
+	uint32_t page_oob_size = mtd->oobsize;
+	int meta = MXS_NAND_METADATA_SIZE;
 	int max_ecc_strength_supported;
 
 	/* Refer to Chapter 17 for i.MX6DQ, Chapter 18 for i.MX6SX */
@@ -162,20 +208,55 @@ static inline uint32_t mxs_nand_get_ecc_strength(uint32_t page_data_size,
 	else
 		max_ecc_strength_supported = 40;
 
-	/*
-	 * Determine the ECC layout with the formula:
-	 *	ECC bits per chunk = (total page spare data bits) /
-	 *		(bits per ECC level) / (chunks per page)
-	 * where:
-	 *	total page spare data bits =
-	 *		(page oob size - meta data size) * (bits per byte)
-	 */
-	ecc_strength = ((page_oob_size - MXS_NAND_METADATA_SIZE) * 8)
-			/ (galois_field *
-			   mxs_nand_ecc_chunk_cnt(page_data_size));
+	if (chip->ecc_strength_ds > max_ecc_strength_supported) {
+		printf("cannot support the NAND, ecc too weak\n");
+		return -EINVAL;
+	}
 
-	return min(round_down(ecc_strength, 2), max_ecc_strength_supported);
-}
+	if (!(chip->ecc_strength_ds > 0 && chip->ecc_step_ds > 0) &&
+			!(page_oob_size > 1024)) {
+		printf("cannot support the NAND, missing necessary info\n");
+		return -EINVAL;
+	}
+
+	/* set some parameters according to NAND chip parameters */
+	chunk_data_size = chip->ecc_step_ds;
+	if (1024 == chunk_data_size)
+		galois_field = 14;
+	if (chunk_data_size < page_oob_size)
+		large_oob_flag = true;
+
+	if (large_oob_flag) {
+		/* start from the minimum ecc NAND chips required */
+		ecc_strength = chip->ecc_strength_ds;
+		while (!(ecc_strength > max_ecc_strength_supported)) {
+			if (mxs_nand_bbm_in_data_chunk(mtd,
+						galois_field,
+						&bbm_chunk))
+				break;
+			ecc_strength += 2;
+		}
+		/*
+		 * if all supported ecc cannot satisfy the bbm
+		 * requirement, change * the ecc layout to meta
+		 * with ecc type.
+		 *
+		 */
+		if (ecc_strength > max_ecc_strength_supported) {
+			ecc_strength = chip->ecc_strength_ds;
+			ecc_for_meta = true;
+			/* calculate in which chunk bbm located */
+			bbm_chunk = (mtd->writesize * 8 - meta * 8 -
+				galois_field * ecc_strength) /
+				(galois_field * ecc_strength +
+				chunk_data_size * 8) + 1;
+		}
+	} else {
+		ecc_strength = chip->ecc_strength_ds;
+		ecc_strength += ecc_strength & 1;
+	}
+	return 0;
+};
 
 static inline uint32_t mxs_nand_get_mark_offset(uint32_t page_data_size,
 						uint32_t ecc_strength)
@@ -196,8 +277,13 @@ static inline uint32_t mxs_nand_get_mark_offset(uint32_t page_data_size,
 	/* Compute the bit offset of the block mark within the physical page. */
 	block_mark_bit_offset = page_data_size * 8;
 
-	/* Subtract the metadata bits. */
-	block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8;
+	if (ecc_for_meta)
+		/* Subtract the metadata bits and ecc bits. */
+		block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8
+					+ chunk_ecc_size_in_bits;
+	else
+		/* Subtract the metadata bits. */
+		block_mark_bit_offset -= MXS_NAND_METADATA_SIZE * 8;
 
 	/*
 	 * Compute the chunk number (starting at zero) in which the block mark
@@ -228,15 +314,11 @@ static inline uint32_t mxs_nand_get_mark_offset(uint32_t page_data_size,
 
 static uint32_t mxs_nand_mark_byte_offset(struct mtd_info *mtd)
 {
-	uint32_t ecc_strength;
-	ecc_strength = mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize);
 	return mxs_nand_get_mark_offset(mtd->writesize, ecc_strength) >> 3;
 }
 
 static uint32_t mxs_nand_mark_bit_offset(struct mtd_info *mtd)
 {
-	uint32_t ecc_strength;
-	ecc_strength = mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize);
 	return mxs_nand_get_mark_offset(mtd->writesize, ecc_strength) & 0x7;
 }
 
@@ -557,6 +639,45 @@ static uint8_t mxs_nand_read_byte(struct mtd_info *mtd)
 	return buf;
 }
 
+static bool mxs_nand_erased_page(struct mtd_info *mtd, struct nand_chip *nand,
+				 uint8_t *buf, int chunk, int page)
+{
+	int gf_len = galois_field;
+	unsigned int flip_bits = 0, flip_bits_noecc = 0;
+	unsigned int threshold;
+	unsigned int ecc_chunkn_size = MXS_NAND_CHUNK_DATA_CHUNK_SIZE;
+	unsigned int base = ecc_chunkn_size * chunk;
+	uint32_t *dma_buf = (uint32_t *)buf;
+	int i;
+
+	threshold = gf_len / 2;
+	if (threshold > ecc_strength)
+		threshold = ecc_strength;
+
+	for (i = 0; i < ecc_chunkn_size; i++) {
+		flip_bits += hweight8(~buf[base + i]);
+		if (flip_bits > threshold)
+			return false;
+	}
+
+	nand->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+	nand->read_buf(mtd, buf, mtd->writesize);
+
+	for (i = 0; i < mtd->writesize / 4; i++) {
+		flip_bits_noecc += hweight32(~dma_buf[i]);
+		if (flip_bits_noecc > threshold)
+			return false;
+	}
+
+	mtd->ecc_stats.corrected += flip_bits;
+
+	memset(buf, 0xff, mtd->writesize);
+
+	printf("The page(%d) is an erased page(%d,%d,%d,%d).\n", page, chunk, threshold, flip_bits, flip_bits_noecc);
+
+	return true;
+}
+
 /*
  * Read a page from NAND.
  */
@@ -566,10 +687,12 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 {
 	struct mxs_nand_info *nand_info = nand_get_controller_data(nand);
 	struct mxs_dma_desc *d;
+	struct mxs_bch_regs *bch_regs = (struct mxs_bch_regs *)MXS_BCH_BASE;
 	uint32_t channel = MXS_DMA_CHANNEL_AHB_APBH_GPMI0 + nand_info->cur_chip;
 	uint32_t corrected = 0, failed = 0;
 	uint8_t	*status;
 	int i, ret;
+	int flag = 0;
 
 	/* Compile the DMA descriptor - wait for ready. */
 	d = mxs_nand_get_dma_desc(nand_info);
@@ -659,6 +782,8 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 		goto rtn;
 	}
 
+	mxs_nand_return_dma_descs(nand_info);
+
 	/* Invalidate caches */
 	mxs_nand_inval_data_buf(nand_info);
 
@@ -671,10 +796,18 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 		if (status[i] == 0x00)
 			continue;
 
-		if (status[i] == 0xff)
+		if (status[i] == 0xff) {
+			if (is_mx6dqp() || is_soc_type(MXC_SOC_MX7) ||
+			    is_cpu_type(MXC_CPU_MX6UL))
+				if (readl(&bch_regs->hw_bch_debug1))
+					flag = 1;
 			continue;
+		}
 
 		if (status[i] == 0xfe) {
+			if (mxs_nand_erased_page(mtd, nand,
+						 nand_info->data_buf, i, page))
+				break;
 			failed++;
 			continue;
 		}
@@ -701,6 +834,9 @@ static int mxs_nand_ecc_read_page(struct mtd_info *mtd, struct nand_chip *nand,
 
 	memcpy(buf, nand_info->data_buf, mtd->writesize);
 
+	if (flag)
+		memset(buf, 0xff, mtd->writesize);
+
 rtn:
 	mxs_nand_return_dma_descs(nand_info);
 
@@ -992,15 +1128,8 @@ static int mxs_nand_scan_bbt(struct mtd_info *mtd)
 	struct mxs_bch_regs *bch_regs = (struct mxs_bch_regs *)MXS_BCH_BASE;
 	uint32_t tmp;
 
-	if (mtd->oobsize > MXS_NAND_CHUNK_DATA_CHUNK_SIZE) {
-		galois_field = 14;
-		chunk_data_size = MXS_NAND_CHUNK_DATA_CHUNK_SIZE * 2;
-	}
-
-	if (mtd->oobsize > chunk_data_size) {
-		printf("Not support the NAND chips whose oob size is larger then %d bytes!\n", chunk_data_size);
-		return -EINVAL;
-	}
+	/* calculate ecc_strength, bbm_chunk, eec_for meta, if necessary */
+	mxs_nand_get_ecc_strength(mtd);
 
 	/* Configure BCH and set NFC geometry */
 	mxs_reset_block(&bch_regs->hw_bch_ctrl_reg);
@@ -1009,22 +1138,33 @@ static int mxs_nand_scan_bbt(struct mtd_info *mtd)
 	tmp = (mxs_nand_ecc_chunk_cnt(mtd->writesize) - 1)
 		<< BCH_FLASHLAYOUT0_NBLOCKS_OFFSET;
 	tmp |= MXS_NAND_METADATA_SIZE << BCH_FLASHLAYOUT0_META_SIZE_OFFSET;
-	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
+	tmp |= (ecc_strength >> 1)
 		<< BCH_FLASHLAYOUT0_ECC0_OFFSET;
-	tmp |= chunk_data_size >> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
-	tmp |= (14 == galois_field ? 1 : 0) <<
-		BCH_FLASHLAYOUT0_GF13_0_GF14_1_OFFSET;
+	if (!ecc_for_meta)
+		tmp |= chunk_data_size
+			>> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
+	else
+		/* set data0 size as 0 */
+		tmp &= ~BCH_FLASHLAYOUT0_DATA0_SIZE_MASK;
+	tmp |= (14 == galois_field ? 1 : 0)
+		<< BCH_FLASHLAYOUT0_GF13_0_GF14_1_OFFSET;
 	writel(tmp, &bch_regs->hw_bch_flash0layout0);
 
 	tmp = (mtd->writesize + mtd->oobsize)
 		<< BCH_FLASHLAYOUT1_PAGE_SIZE_OFFSET;
-	tmp |= (mxs_nand_get_ecc_strength(mtd->writesize, mtd->oobsize) >> 1)
+	tmp |= (ecc_strength >> 1)
 		<< BCH_FLASHLAYOUT1_ECCN_OFFSET;
 	tmp |= chunk_data_size >> MXS_NAND_CHUNK_DATA_CHUNK_SIZE_SHIFT;
 	tmp |= (14 == galois_field ? 1 : 0) <<
 		BCH_FLASHLAYOUT1_GF13_0_GF14_1_OFFSET;
 	writel(tmp, &bch_regs->hw_bch_flash0layout1);
 
+	/* Set erase threshold to ecc strength for mx6ul, mx6qp and mx7 */
+	if (is_mx6dqp() || is_soc_type(MXC_SOC_MX7) ||
+	    is_cpu_type(MXC_CPU_MX6UL))
+		writel(BCH_MODE_ERASE_THRESHOLD(ecc_strength),
+		       &bch_regs->hw_bch_mode);
+
 	/* Set *all* chip selects to use layout 0 */
 	writel(0, &bch_regs->hw_bch_layoutselect);
 
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index 6840908..d020378 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -1110,7 +1110,8 @@ err1:
 	return ret;
 }
 
-int fecmxc_initialize_multi(bd_t *bd, int dev_id, int phy_id, uint32_t addr)
+int fecmxc_initialize_multi(bd_t *bd, int dev_id, int phy_id,
+			    uint32_t addr, uint32_t addr_mii)
 {
 	uint32_t base_mii;
 	struct mii_dev *bus = NULL;
@@ -1126,7 +1127,7 @@ int fecmxc_initialize_multi(bd_t *bd, int dev_id, int phy_id, uint32_t addr)
 	 */
 	base_mii = MXS_ENET0_BASE;
 #else
-	base_mii = addr;
+	base_mii = addr_mii;
 #endif
 	debug("eth_init: fec_probe(bd, %i, %i) @ %08x\n", dev_id, phy_id, addr);
 	bus = fec_get_miibus(base_mii, dev_id);
@@ -1157,7 +1158,7 @@ int fecmxc_initialize_multi(bd_t *bd, int dev_id, int phy_id, uint32_t addr)
 int fecmxc_initialize(bd_t *bd)
 {
 	return fecmxc_initialize_multi(bd, -1, CONFIG_FEC_MXC_PHYADDR,
-			IMX_FEC_BASE);
+				       IMX_FEC_BASE, IMX_FEC_BASE);
 }
 #endif
 
diff --git a/drivers/usb/host/ehci-mx6.c b/drivers/usb/host/ehci-mx6.c
index f348ec9..7bb3e5c 100644
--- a/drivers/usb/host/ehci-mx6.c
+++ b/drivers/usb/host/ehci-mx6.c
@@ -338,6 +338,8 @@ int ehci_mx6_common_init(struct usb_ehci *ehci, int index)
 }
 
 #ifndef CONFIG_DM_USB
+#include <asm/arch/sys_proto.h>
+
 int ehci_hcd_init(int index, enum usb_init_type init,
 		struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 {
@@ -346,6 +348,7 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 	u32 controller_spacing = 0x200;
 #elif defined(CONFIG_MX7)
 	u32 controller_spacing = 0x10000;
+	u32 cpurev = get_cpu_rev();
 #endif
 	struct usb_ehci *ehci = (struct usb_ehci *)(USB_BASE_ADDR +
 		(controller_spacing * index));
@@ -354,6 +357,12 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 	if (index > 3)
 		return -EINVAL;
 
+#if defined (CONFIG_MX7)
+	/* Initialize only one port for i.MX7Solo */
+	if (((cpurev & 0xFF000) >> 12) == MXC_CPU_MX7S)
+		if (index > 0)
+			return -ENODEV;
+#endif
 	ret = ehci_mx6_common_init(ehci, index);
 	if (ret)
 		return ret;
diff --git a/drivers/video/mxsfb.c b/drivers/video/mxsfb.c
index 20455ff..197b9df 100644
--- a/drivers/video/mxsfb.c
+++ b/drivers/video/mxsfb.c
@@ -50,12 +50,15 @@ __weak void mxsfb_system_setup(void)
 static void mxs_lcd_init(GraphicDevice *panel,
 			struct ctfb_res_modes *mode, int bpp)
 {
+	int ret;
 	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)MXS_LCDIF_BASE;
 	uint32_t word_len = 0, bus_width = 0;
 	uint8_t valid_data = 0;
 
 	/* Kick in the LCDIF clock */
-	mxs_set_lcdclk(MXS_LCDIF_BASE, PS2KHZ(mode->pixclock));
+	ret = mxs_set_lcdclk(MXS_LCDIF_BASE, PS2KHZ(mode->pixclock));
+	if (ret < 0)
+		return;
 
 	/* Restart the LCDIF block */
 	mxs_reset_block(&regs->hw_lcdif_ctrl_reg);
diff --git a/include/common.h b/include/common.h
index 1a98512..9dbb34f 100644
--- a/include/common.h
+++ b/include/common.h
@@ -379,16 +379,18 @@ void	fdc_hw_init   (void);
 /* $(BOARD)/eeprom.c */
 #ifdef CONFIG_CMD_EEPROM
 void eeprom_init  (int bus);
-int  eeprom_read  (unsigned dev_addr, unsigned offset, uchar *buffer, unsigned cnt);
-int  eeprom_write (unsigned dev_addr, unsigned offset, uchar *buffer, unsigned cnt);
+int  eeprom_read  (unsigned dev_addr, unsigned offset, uchar *buffer,
+		   unsigned cnt, int set_bus);
+int  eeprom_write (unsigned dev_addr, unsigned offset, uchar *buffer,
+		   unsigned cnt, int set_bus);
 #else
 /*
  * Some EEPROM code is depecated because it used the legacy I2C interface. Add
  * some macros here so we don't have to touch every one of those uses
  */
 #define eeprom_init(bus)
-#define eeprom_read(dev_addr, offset, buffer, cnt) ((void)-ENOSYS)
-#define eeprom_write(dev_addr, offset, buffer, cnt) ((void)-ENOSYS)
+#define eeprom_read(dev_addr, offset, buffer, cnt, set_bus) ((void)-ENOSYS)
+#define eeprom_write(dev_addr, offset, buffer, cnt, set_bus) ((void)-ENOSYS)
 #endif
 
 /*
diff --git a/include/configs/cl-som-imx7.h b/include/configs/cl-som-imx7.h
new file mode 100644
index 0000000..415944a
--- /dev/null
+++ b/include/configs/cl-som-imx7.h
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2015 CompuLab, Ltd.
+ *
+ * Configuration settings for the CompuLab CL-SOM-iMX7 System-on-Module.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CL_SOM_IMX7_CONFIG_H
+#define __CL_SOM_IMX7_CONFIG_H
+
+#include "mx7_common.h"
+
+#define CONFIG_DBG_MONITOR
+
+#define CONFIG_MXC_UART_BASE            UART1_IPS_BASE_ADDR
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
+
+#define CONFIG_BOARD_LATE_INIT
+
+/* Uncomment to enable secure boot support */
+/* #define CONFIG_SECURE_BOOT */
+#define CONFIG_CSF_SIZE			0x4000
+
+/* Network */
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          0
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+/* ENET1 */
+#define IMX_FEC_BASE			ENET_IPS_BASE_ADDR
+
+/* PMIC */
+#define CONFIG_POWER
+#define CONFIG_POWER_I2C
+#define CONFIG_POWER_PFUZE3000
+#define CONFIG_POWER_PFUZE3000_I2C_ADDR	0x08
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+/* I2C configs */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C2		/* Enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C4		/* Enable I2C bus 4 */
+#define CONFIG_SYS_I2C_SPEED		100000
+#define SYS_I2C_BUS_SOM			0
+#define CL_SOM_IMX7_I2C_BUS_EXT		1
+
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x50
+#define CL_SOM_IMX7_I2C_EEPROM_EXT	0x54
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_I2C_EEPROM_BUS	SYS_I2C_BUS_SOM
+
+#define CONFIG_PCA953X
+#define CONFIG_CMD_PCA953X
+#define CONFIG_CMD_PCA953X_INFO
+#define CONFIG_SYS_I2C_PCA953X_ADDR	0x20
+#define CONFIG_SYS_I2C_PCA953X_WIDTH	{ {0x20, 16} }
+
+#undef CONFIG_SYS_AUTOLOAD
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+#undef CONFIG_BOOTDELAY
+
+#define CONFIG_BOOTDELAY		3
+#define CONFIG_SYS_AUTOLOAD		"no"
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"autoload=off\0" \
+	"script=boot.scr\0" \
+	"loadscript=load ${storagetype} ${storagedev} ${loadaddr} ${script};\0" \
+	"loadkernel=load ${storagetype} ${storagedev} ${loadaddr} ${kernel};\0" \
+	"loadkernel_nand=nand read ${loadaddr} 0 ${kernel_size}\0" \
+	"loadfdt=load ${storagetype} ${storagedev} ${fdtaddr} ${fdtfile};\0" \
+	"loadfdt_nand=nand read ${fdtaddr} 980000 10000\0" \
+	"bootscript=echo Running bootscript from ${storagetype} ...; source ${loadaddr};\0" \
+	"storagebootcmd=echo Booting from ${storagetype} ...; run ${storagetype}args; run doboot;\0" \
+	"kernel=zImage\0" \
+	"kernel_size=800000\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdtaddr=0x83000000\0" \
+	"mmcdev_def="__stringify(CONFIG_SYS_MMC_DEV)"\0" \
+	"usbdev_def="__stringify(CONFIG_SYS_USB_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"usbpart=" __stringify(CONFIG_SYS_USB_IMG_LOAD_PART) "\0" \
+	"doboot=bootz ${loadaddr} - ${fdtaddr}\0" \
+	"mmc_config=mmc dev ${mmcdev}; mmc rescan\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/mmcblk${mmcblk}p2 rootwait rw\0" \
+	"nandargs=setenv bootargs console=${console},${baudrate} " \
+		"root=ubi0:rootfs rw rootfstype=ubifs ubi.mtd=rootfs\0" \
+	"mmcbootscript=" \
+		"if run mmc_config; then " \
+			"setenv storagetype mmc;" \
+			"setenv storagedev ${mmcdev}:${mmcpart};" \
+			"if run loadscript; then " \
+				"run bootscript; " \
+			"fi; " \
+		"fi;\0" \
+	"mmcboot=" \
+		"if run mmc_config; then " \
+			"setenv storagetype mmc;" \
+			"setenv storagedev ${mmcdev}:${mmcpart};" \
+			"if run loadkernel; then " \
+				"if run loadfdt; then " \
+					"run storagebootcmd;" \
+				"fi; " \
+			"fi; " \
+		"fi;\0" \
+	"sdbootscript=setenv mmcdev ${mmcdev_def}; setenv mmcblk 0; " \
+		"run mmcbootscript\0" \
+	"usbbootscript=setenv usbdev ${usbdev_def}; " \
+		"setenv storagetype usb;" \
+		"setenv storagedev ${usbdev}:${usbpart};" \
+		"if run loadscript; then " \
+			"run bootscript; " \
+		"fi;\0" \
+	"sdboot=setenv mmcdev ${mmcdev_def}; setenv mmcblk 0; run mmcboot\0" \
+	"emmcbootscript=setenv mmcdev 1; setenv mmcblk 2; run mmcbootscript\0" \
+	"emmcboot=setenv mmcdev 1; setenv mmcblk 2; run mmcboot\0" \
+	"nandboot=" \
+		"setenv storagetype nand;" \
+		"if run loadkernel_nand; then " \
+			"if run loadfdt_nand; then " \
+				"run storagebootcmd;" \
+			"fi; " \
+		"fi;\0" \
+	"displaytype=dvi\0" \
+	"stdin=serial,usbkbd\0" \
+	"baseboard_i2c_enable=true\0" \
+
+#define CONFIG_PREBOOT                 "usb start"
+
+#define CONFIG_BOOTCOMMAND \
+	"echo SD boot attempt ...; run sdbootscript; run sdboot; " \
+	"echo eMMC boot attempt ...; run emmcbootscript; run emmcboot; " \
+	"echo USB boot attempt ...; run usbbootscript; " \
+	"echo NAND boot attempt  ...; run nandboot"
+
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x20000000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* SPI Flash support */
+#define CONFIG_SPI
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS		0
+#define CONFIG_SF_DEFAULT_CS		0
+#define CONFIG_SF_DEFAULT_SPEED		20000000
+#define CONFIG_SF_DEFAULT_MODE		(SPI_MODE_0)
+
+/* FLASH and environment organization */
+#define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+
+/* EEPROM */
+#define CONFIG_CMD_EEPROM
+#define CONFIG_ENV_EEPROM_IS_ON_I2C
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS      4
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS  5
+#define CONFIG_SYS_EEPROM_SIZE                 256
+
+#define CONFIG_CMD_EEPROM_LAYOUT
+#define CONFIG_EEPROM_LAYOUT_HELP_STRING "v2, v3"
+
+/* MMC Config*/
+#define CONFIG_FSL_USDHC
+#ifdef CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR       USDHC1_BASE_ADDR
+
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2" /* USDHC1 */
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#endif
+
+/* USB Configs */
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+#define CONFIG_SYS_STDIO_DEREGISTER
+
+/* Uncomment to enable iMX thermal driver support */
+/*#define CONFIG_IMX_THERMAL*/
+
+/* SPL */
+#include "imx7_spl.h"
+#ifdef CONFIG_SPL_BUILD
+#define CONFIG_SPL_SPI_LOAD
+#define CONFIG_SYS_SPI_U_BOOT_OFFS	(64 * 1024)
+#else /* !CONFIG_SPL_BUILD */
+/* NAND configuration */
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x40000000
+#define CONFIG_SYS_NAND_MAX_CHIPS      1
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+/* APBH DMA is required for NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif /* CONFIG_SPL_BUILD */
+
+/* Display */
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MXS
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_SPLASH_SOURCE
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_ENV_CALLBACK_LIST_STATIC "displaytype:displaytype"
+#endif /* CONFIG_VIDEO */
+
+/* Miscellaneous */
+#define CONFIG_DISPLAY_BOARDINFO_LATE
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/imx7_spl.h b/include/configs/imx7_spl.h
new file mode 100644
index 0000000..e562cdb
--- /dev/null
+++ b/include/configs/imx7_spl.h
@@ -0,0 +1,67 @@
+/*
+ * SPL definitions for the i.MX7 SPL
+ *
+ * (C) Copyright 2017 CompuLab, Ltd. http://www.compulab.com
+ *
+ * Author: Uri Mashiach <uri.mashiach@compulab.co.il>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __IMX7_SPL_CONFIG_H
+#define __IMX7_SPL_CONFIG_H
+
+#ifdef CONFIG_SPL
+
+#define CONFIG_SPL_FRAMEWORK
+
+/*
+ * see figure 6-22 in i.MX 7Dual/Solo Reference manuals:
+ *  - IMX7D/S OCRAM free area RAM (OCRAM) is from 0x00910000 to
+ *    0x00946C00.
+ *  - Set the stack at the end of the free area section, at 0x00946BB8.
+ *  - The BOOT ROM loads what they consider the firmware image
+ *    which consists of a 4K header in front of us that contains the IVT, DCD
+ *    and some padding thus 'our' max size is really 0x00946BB8 - 0x00911000.
+ *    64KB is more then enough for the SPL.
+ */
+#define CONFIG_SPL_TEXT_BASE		0x00911000
+#define CONFIG_SPL_MAX_SIZE		0x10000
+#define CONFIG_SPL_STACK		0x00946BB8
+/*
+ * Pad SPL to 68KB (4KB header + 64KB max size). This allows to write the
+ * SPL/U-Boot combination generated with u-boot-with-spl.imx directly to a
+ * boot media (given that boot media specific offset is configured properly).
+ */
+#define CONFIG_SPL_PAD_TO		0x11000
+
+/* MMC support */
+#if defined(CONFIG_SPL_MMC_SUPPORT)
+#define CONFIG_SYS_MMCSD_FS_BOOT_PARTITION	1
+#define CONFIG_SYS_MONITOR_LEN			409600	/* 400 KB */
+#endif
+
+/* SATA support */
+#if defined(CONFIG_SPL_SATA_SUPPORT)
+#define CONFIG_SPL_SATA_BOOT_DEVICE		0
+#define CONFIG_SYS_SATA_FAT_BOOT_PARTITION	1
+#endif
+
+/* Define the payload for FAT/EXT support */
+#if defined(CONFIG_SPL_FAT_SUPPORT) || defined(CONFIG_SPL_EXT_SUPPORT)
+# ifdef CONFIG_OF_CONTROL
+#  define CONFIG_SPL_FS_LOAD_PAYLOAD_NAME	"u-boot-dtb.img"
+# else
+#  define CONFIG_SPL_FS_LOAD_PAYLOAD_NAME	"u-boot.img"
+# endif
+#endif
+
+#define CONFIG_SPL_BSS_START_ADDR      0x88200000
+#define CONFIG_SPL_BSS_MAX_SIZE        0x100000		/* 1 MB */
+#define CONFIG_SYS_SPL_MALLOC_START    0x88300000
+#define CONFIG_SYS_SPL_MALLOC_SIZE     0x100000		/* 1 MB */
+#define CONFIG_SYS_TEXT_BASE           0x87800000
+
+#endif /* CONFIG_SPL */
+
+#endif /* __IMX7_SPL_CONFIG_H */
diff --git a/include/configs/tam3517-common.h b/include/configs/tam3517-common.h
index 0b87c9c..97db6d0 100644
--- a/include/configs/tam3517-common.h
+++ b/include/configs/tam3517-common.h
@@ -321,7 +321,7 @@ struct tam3517_module_info {
 do {								\
 	i2c_init(CONFIG_SYS_OMAP24_I2C_SPEED, CONFIG_SYS_OMAP24_I2C_SLAVE); \
 	if (eeprom_read(CONFIG_SYS_I2C_EEPROM_ADDR, 0,		\
-		(void *)info, sizeof(*info)))			\
+			(void *)info, sizeof(*info)), 1)	\
 		ret = 1;					\
 	else							\
 		ret = 0;					\
diff --git a/include/eeprom_field.h b/include/eeprom_field.h
index 94e259f..aff91a3 100644
--- a/include/eeprom_field.h
+++ b/include/eeprom_field.h
@@ -15,25 +15,36 @@
 struct eeprom_field {
 	char *name;
 	int size;
-	unsigned char *buf;
 
-	void (*print)(const struct eeprom_field *eeprom_field);
-	int (*update)(struct eeprom_field *eeprom_field, char *value);
+	void (*print)(const struct eeprom_field *eeprom_field, uchar *fbuf);
+	int (*update)(struct eeprom_field *eeprom_field, uchar *fbuf,
+		      char *value);
+	int (*read)(const struct eeprom_field *field, uchar *fbuf, uchar *buf,
+		    int buf_size);
 };
 
-void eeprom_field_print_bin(const struct eeprom_field *field);
-int eeprom_field_update_bin(struct eeprom_field *field, char *value);
-
-void eeprom_field_print_bin_rev(const struct eeprom_field *field);
-int eeprom_field_update_bin_rev(struct eeprom_field *field, char *value);
-
-void eeprom_field_print_mac(const struct eeprom_field *field);
-int eeprom_field_update_mac(struct eeprom_field *field, char *value);
-
-void eeprom_field_print_ascii(const struct eeprom_field *field);
-int eeprom_field_update_ascii(struct eeprom_field *field, char *value);
-
-void eeprom_field_print_reserved(const struct eeprom_field *field);
-int eeprom_field_update_reserved(struct eeprom_field *field, char *value);
+void eeprom_field_print_bin(const struct eeprom_field *field, uchar *fbuf);
+int eeprom_field_update_bin(struct eeprom_field *field, uchar *fbuf,
+			    char *value);
+int eeprom_field_read_bin(const struct eeprom_field *field, uchar *fbuf,
+			  uchar *buf, int buf_size);
+
+void eeprom_field_print_bin_rev(const struct eeprom_field *field, uchar *fbuf);
+int eeprom_field_update_bin_rev(struct eeprom_field *field, uchar *fbuf,
+				char *value);
+int eeprom_field_read_rev(const struct eeprom_field *field, uchar *fbuf,
+			  uchar *buf, int buf_size);
+
+void eeprom_field_print_mac(const struct eeprom_field *field, uchar *fbuf);
+int eeprom_field_update_mac(struct eeprom_field *field, uchar *fbuf,
+			    char *value);
+
+void eeprom_field_print_ascii(const struct eeprom_field *field, uchar *fbuf);
+int eeprom_field_update_ascii(struct eeprom_field *field, uchar *fbuf,
+			      char *value);
+
+void eeprom_field_print_reserved(const struct eeprom_field *field, uchar *fbuf);
+int eeprom_field_update_reserved(struct eeprom_field *field, uchar *fbuf,
+				 char *value);
 
 #endif
diff --git a/include/eeprom_layout.h b/include/eeprom_layout.h
index 459b99d..808a458 100644
--- a/include/eeprom_layout.h
+++ b/include/eeprom_layout.h
@@ -23,6 +23,8 @@ struct eeprom_layout {
 	void (*print)(const struct eeprom_layout *eeprom_layout);
 	int (*update)(struct eeprom_layout *eeprom_layout, char *field_name,
 		      char *new_data);
+	int (*read)(struct eeprom_layout *eeprom_layout, char *field_name,
+		    uchar *buf, int buf_size);
 };
 
 void eeprom_layout_setup(struct eeprom_layout *layout, unsigned char *buf,
diff --git a/include/netdev.h b/include/netdev.h
index c06b908..5aa98ac 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -46,7 +46,8 @@ int eth_3com_initialize (bd_t * bis);
 int ethoc_initialize(u8 dev_num, int base_addr);
 int fec_initialize (bd_t *bis);
 int fecmxc_initialize(bd_t *bis);
-int fecmxc_initialize_multi(bd_t *bis, int dev_id, int phy_id, uint32_t addr);
+int fecmxc_initialize_multi(bd_t *bis, int dev_id, int phy_id,
+			    uint32_t addr, uint32_t addr_mii);
 int ftgmac100_initialize(bd_t *bits);
 int ftmac100_initialize(bd_t *bits);
 int ftmac110_initialize(bd_t *bits);
diff --git a/tools/logos/compulab.bmp b/tools/logos/compulab.bmp
index df5435c..cae6779 100644
Binary files a/tools/logos/compulab.bmp and b/tools/logos/compulab.bmp differ
